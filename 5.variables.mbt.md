# 第 5 章 变量、常量与作用域

目标：理解“绑定”与“可变性”在 MoonBit 中的语义；学会选择 `let`、`mut`、`const`；避免无意修改、名称冲突与作用域泄漏；建立良好命名与生命周期习惯。

---

## 5.1 绑定是什么？

在许多编程语言中，我们习惯使用“赋值”这个词，想象将一个数据放入一个名为变量的“盒子”里。但在 MoonBit 以及现代函数式编程语言中，我们更倾向于使用“绑定（Binding）”这个概念。绑定是将一个名字（标识符）与一个值建立关联的过程，就像给某个数据贴上了一个标签。

默认情况下，使用 `let` 关键字创建的绑定是**不可变（Immutable）**的。这意味着一旦你将名字 `x` 绑定到数值 `5`，在这个名字的生命周期内，它就永远代表 `5`。你不能指着同一个 `x` 说“把你改成 6”。这种限制是刻意设计的特性，它极大地简化了代码推理：当你看到 `x` 时，不需要回溯几十行代码去担心它是否在某个角落被悄悄修改了。不可变性是编写安全、并发友好代码的基石。

```moonbit expr
fn main {
  // 创建一个绑定：将名字 x 关联到值 5
  let x = 5

  // 使用 x 的值来计算 y。此时 x 依然是 5，不可更改。
  let y = x + 2

  println(y)
  // x = 6 // 如果尝试这行代码，编译器会报错，因为 x 是不可变的
}
```

这里 `x` 与 `y` 只是值的“引用名字”，不代表可更改的盒子。

### 练习 5-1

- 写两个不可变绑定：`base = 10`、`height = 5`，再计算面积并打印。

---

## 5.2 可变绑定：`mut`

虽然不可变性有很多好处，但在现实世界的编程中，我们确实需要表达“状态的变化”，比如游戏中的得分、循环中的计数器或者物理模拟中的位置。MoonBit 提供了 `mut` 关键字来显式地声明一个绑定是**可变（Mutable）**的。

当你看到 `let mut` 时，这是一个醒目的信号，告诉读者：“注意，这个变量的值在后续代码中可能会发生改变”。这种显式的标记将“变化”这一复杂行为隔离了出来。在阅读代码时，你可以放心地忽略那些普通的 `let` 绑定，而重点关注 `mut` 绑定，因为那里才是状态发生改变、可能产生 Bug 的地方。虽然 `mut` 提供了灵活性，但过度使用会使程序的控制流变得难以追踪，因此建议仅在确实需要更新状态时使用。

```moonbit expr
fn main {
  // 显式声明 count 是可变的
  let mut count = 0

  // 原地修改 count 绑定的值
  count = count + 1 // 你也可以写成 count += 1
  count = count + 5

  println(count)
}
```

误区：过度使用 `mut` 会让代码难以阅读（谁修改了值？何时？）。若只是“基于旧值计算新值”，可新建绑定而非原地更改。

### 练习 5-2

```moonbit expr
let mut a = 10
a = a + 5
a = a * 10
```

- 将一个使用多次 `mut` 自增的代码改写为不可变链式计算（新建多个 `stepX` 绑定）。

---

## 5.3 常量：`const`

常量与不可变变量虽然都不能被修改，但它们有着本质的区别。变量（Variable）是在**运行时**计算和分配的，而常量（Constant）是在**编译时**就已经确定的值。

使用 `const` 定义的值必须是编译器能够直接推断出的字面量或简单表达式。常量通常用于消除代码中的“魔法数字（Magic Numbers）”——即那些直接出现在代码中、含义不明的数字或字符串。将它们定义为常量并赋予有意义的名字（如 `MAX_RETRY_COUNT`），不仅能提高代码的可读性，还能在需要调整参数时，只需修改一处即可全局生效。常量通常具有全局或模块级的作用域，并且在编译后的代码中可能会被直接内联，从而带来微小的性能优势。

```moonbit expr
// 这是一个编译期常量，程序运行前就已经确定
const PI = 3.14159
const DEFAULT_SIZE = 100

fn main {
  // 使用常量就像使用字面量一样
  let area = PI * 10.0 * 10.0
  println(area)
  println(DEFAULT_SIZE)
}
```

用途：配置值、尺寸、固定字符串。命名建议全大写下划线：`MAX_LIMIT`。不要把需要动态计算的结果放入 const（编译器会报无法确定），也不要用**小写的**名称来定义常量。

### 练习 5-3

- 定义一个常量 `GREETING` 并在函数中引用。

---

## 5.4 类型注解的好处

MoonBit 拥有强大的类型推断系统，大多数情况下你不需要显式写出变量的类型，编译器能根据上下文自动推导出它是 `Int`、`String` 还是 `Array`。然而，显式的**类型注解（Type Annotation）**依然是非常有价值的习惯。

首先，类型注解是最好的“代码文档”。当你写下 `let id : Int = 42` 时，你明确地告诉了阅读者（以及未来的自己）这个变量的预期用途。其次，在复杂的表达式链条中，类型推断可能会因为信息不足而失败，或者推导出非预期的类型，显式注解可以作为“锚点”帮助编译器进行检查。最后，当代码报错时，显式注解能让错误信息更精准地指向问题所在，而不是报出一个令人困惑的类型不匹配错误。

```moonbit expr
fn main {
  // 显式注解：虽然 42 显然是 Int，但写出来增加了可读性
  let id : Int = 42

  // 显式注解：确保 name 被视为 String
  let name : String = "moon"

  println(id)
}
```

### 练习 5-4

- 去掉类型注解再运行，观察是否行为一致，再加回注解。

---

## 5.5 作用域（Scope）与生命周期

**作用域（Scope）**定义了变量在代码中的可见范围，而**生命周期（Lifetime）**则描述了变量在内存中存在的时间。在 MoonBit 中，作用域主要由花括号 `{}` 定义的**块（Block）**来决定。

当程序执行进入一个新的块（例如 `if` 分支、循环体或手动创建的 `{}` 块）时，就创建了一个新的作用域。在这个内部作用域中定义的变量，只在块内部有效。一旦程序执行离开这个块，这些局部变量就会“失效”，它们占用的资源（在栈上）会被回收，名字也无法再被访问。理解作用域对于管理资源和避免命名冲突至关重要。内层作用域可以访问外层变量，但外层无法访问内层变量，这种单向可见性保证了封装性。

```moonbit expr
fn main {
  let x = 10
  println(x)        // 10

  // 进入一个新的作用域块
  {
    // 这里定义了一个新的 x，它只在这个块内有效
    // 这被称为 Shadowing（遮蔽），它不会影响外层的 x
    let x = 99
    println(x)      // 99
  } // 块结束，内部的 x 失效

  println(x)        // 10，外层的 x 依然存在且值未变
}
```

生命周期直觉：作用域结束后名字失效（被回收或不再可用）。不要在外层使用内层局部临时变量。

### 练习 5-5

- 写嵌套两层块，各层定义 `value` 不同数值并分别打印。

---

## 5.6 Shadowing vs Mutation

初学者常常混淆 **Shadowing（遮蔽）** 和 **Mutation（修改）**。虽然它们看起来都像是“改变了变量的值”，但底层机制完全不同。

Mutation 是使用 `mut` 关键字，在**同一个**内存位置上更新值。变量的名字没变，指向的内存地址没变，只是里面的内容变了。
Shadowing 是使用 `let` 关键字，创建一个**新的**绑定，只是恰好用了和旧变量一样的名字。旧变量依然存在（如果没被优化掉），只是在当前作用域被新名字“挡住”了。Shadowing 的强大之处在于：1. 它可以改变类型（例如把字符串解析为整数后仍叫 `input`）；2. 它可以保持变量的不可变性（新变量默认也是 immutable 的），这在进行一系列数据转换时非常有用。

```moonbit expr
fn main {
  // Shadowing 示例
  let x = 5
  let x = x + 1    // 创建了一个全新的变量 x（和之前那个不是一个哦），值为 6
  println(x)       // 6

  // Mutation 示例
  let mut y = 5
  y = y + 1        // 修改了现有的变量 y
  println(y)
}
```

如何选择：

- 逻辑上“值的一次转换” → 用 shadowing 表达“阶段性新值”。
- 需要在循环或闭包内累积状态 → 用 mutation。

### 练习 5-6

- 用 shadowing 把一个初始字符串多次加工（追加子串），不使用 `mut`。

---

## 5.7 命名与可读性

编程中最难的两件事之一就是“命名”。一个好的变量名能让代码像散文一样易读，而糟糕的命名则会让代码变成天书。在 MoonBit 中，我们遵循一定的命名规范，通常使用蛇形命名法（snake_case），即全小写字母用下划线分隔。

除了格式，更重要的是**语义**。变量名应该描述它“是什么”或“含有什么”，而不是它“怎么实现的”。例如，`is_visible` 比 `flag1` 好得多，`user_list` 比 `arr` 好得多。当然，命名的长度应该与作用域的大小成正比：在只有三行的循环里用 `i` 是完全可以接受的，但在全局作用域或长函数中，`i` 就显得含义不明了。

建议：

- 语义化：`total_price` > `tp`。
- 使用英文或通用缩写，避免魔法字母。
- 布尔变量用肯定陈述：`is_valid`, `has_error`。
- 临时变量可短，但避免过度：`i`、`idx` 在局部循环可接受。

反例：

```moonbit expr
fn bad() -> Unit {
  let a = 100    // a 是什么？
  let b = a + 5  // b 又是什么？
  println(b)
}
```

改良：

```moonbit expr
fn good() -> Unit {
  let base_price = 100
  let final_price = base_price + 5
  println(final_price)
}
```

### 练习 5-7

- 重写一个你写过的示例，把所有命名改得更清晰。

---

## 5.8 常见错误与排查

在处理变量时，新手常会遇到几类典型错误。理解这些错误的根源能帮助你快速定位问题。

第一类是**修改不可变变量**。这是 MoonBit 编译器最严格的检查之一。如果你试图给一个没有 `mut` 标记的变量赋值，编译器会立即报错。这通常意味着你需要重新思考逻辑：是真的需要修改状态（加 `mut`），还是只是需要一个新值（用 `let` 新建变量）。
第二类是**作用域逃逸**。试图在花括号外面访问花括号里面定义的变量。这就像在房子外面找房子里的家具一样，是不可能的。解决方法通常是将变量定义提升到外层作用域，或者让内层块返回一个值。

错误：修改不可变绑定。

```
let x = 5
x = 6  // 报错：immutable
```

解决：改为 `let mut x = 5` 或使用 shadowing：`let x = x + 1`。

错误：使用超出作用域的变量。

```
{
  let inner = 10
}
println(inner) // 报错：未定义
```

解决：把需要的值返回或提升作用域。

错误：命名冲突导致读错含义 → 分清层次或改名。

### 练习 5-8

- 制造一个不可变修改错误并修复；制造一个作用域错误并修复。

---

## 5.9 综合示例：统计并格式化

让我们通过一个实际的例子来对比“命令式风格（使用 Mutation）”和“函数式风格（使用不可变绑定）”。假设我们需要计算一组数字的总和与平均值。

在命令式风格中，我们习惯声明一个可变的 `sum`，然后遍历数组不断修改它。这符合计算机底层的运作方式，但在逻辑复杂时容易出错。
在函数式风格中，我们使用 `fold`（折叠）等高阶函数。我们不再关注“怎么一步步加”，而是关注“如何将两个数合并”。这种写法通常更简洁，且完全避免了中间状态的修改，减少了副作用。

```moonbit expr
// 风格 1：命令式，使用 mut
fn main {
  let numbers = [1,2,3,4]
  let mut sum = 0
  for n in numbers {
    sum = sum + n // 每次循环都在修改 sum
  }
  let average = sum / numbers.length()
  println("sum=\{sum}, avg=\{average}")
}
```

改进（减少 mutation）：

```moonbit expr
// 风格 2：函数式，无 mut
fn main {
  let numbers = [1,2,3,4]
  // fold 抽象了“累加”的过程，acc 是累加器，n 是当前元素
  let sum = numbers.fold(0, fn(acc, n){ acc + n })
  let avg = sum / numbers.length()
  println("sum=\{sum}, avg=\{avg}")
}
```

### 练习 5-9 综合

- 对比两个实现风格——写出你偏好的理由（可写在注释或独立说明）。

---

## 5.10 小结

本章我们深入探讨了 MoonBit 中变量的核心概念。我们学习了**绑定**不仅仅是赋值，而是一种名字与值的关联；**不可变性**是默认的安全策略，而 **`mut`** 是处理状态变化的显式手段。我们区分了**编译期常量**与运行时变量，理解了**作用域**如何控制变量的生命周期，以及 **Shadowing** 如何优雅地处理数据转换。掌握这些基础，是你编写清晰、健壮 MoonBit 代码的第一步。下一章（第 6 章），我们将利用这些变量来控制程序的流向：分支、循环与模式匹配。

---

## 5.11 自测

1. 写一个函数内部使用 shadowing 连续规范化字符串（去空格 → 小写 → 追加后缀）。
2. 写一个循环累加示例，用 `mut` 版与 fold 版各一次。
3. 写一段错误示例并在注释中解释它的错误与修复方式。

（答案在 `appendix/answers.md`）

---

## 5.12 闭包捕获与状态语义

**闭包（Closure）** 是一个可以捕获其周围环境（作用域）中变量的函数。当闭包与可变性结合时，情况会变得有趣且复杂。

如果闭包捕获了一个不可变变量，它只是简单地持有了那个值的一个副本或引用。但如果捕获的是一个 `mut` 变量，闭包内部就可以修改外部的这个变量！这使得闭包可以拥有“内部状态”，表现得像一个微型的对象。然而，这也带来了风险：如果多个闭包共享同一个可变变量，它们之间的交互可能会导致难以预测的结果。因此，最佳实践是尽量限制可变状态的范围，或者将其封装在特定的工厂函数中。

示例：

```moonbit expr
// 工厂函数：创建并返回一个闭包
fn make_counter(start : Int) -> () -> Int {
  let mut c = start // 这个 c 被返回的闭包捕获了

  // 返回的函数每次调用都会修改并返回 c
  fn(){
    c = c + 1
    c
  }
}

fn main {
  let counter = make_counter(10)
  println(counter()) // 11
  println(counter()) // 12
}
```

### 练习 5-12

- 设计一个捕获数组的闭包：每次调用追加一个值并返回当前长度；再写纯函数版本（返回新数组）比较。

---

## 5.13 不可变 vs 性能权衡

在软件工程中，没有银弹。不可变性虽然带来了安全性和可读性，但在某些极端性能敏感的场景下（例如每秒处理百万次更新的游戏循环或数值计算），频繁地创建新对象（而不是修改旧对象）可能会带来内存分配和垃圾回收的压力。

MoonBit 的编译器做了大量优化来减轻这种开销，但在处理大型数组或密集计算时，局部使用 `mut` 往往能获得更好的性能。策略是：**默认使用不可变**，因为它更安全、更易读；当你通过性能分析工具发现某个热点路径存在瓶颈时，再将其局部重构为使用 `mut` 的实现。这种“局部可变，整体不可变”的模式是高性能编程的常见技巧。

示例对比：

```moonbit expr
// 纯函数风格：可能产生较多中间对象（视编译器优化而定）
fn build_seq_pure(n : Int) -> Array[Int] {
  // 伪代码：假设有生成器
  // Array::make(n, ...).map(...)
  [1,2,3]
}

// 局部可变风格：在函数内部使用 mut 追求极致性能，对外依然返回不可变结果
fn build_seq_mut(n : Int) -> Array[Int] {
  let mut acc = [] : Array[Int]
  let mut i = 0
  while i < n {
    acc.push(i)
    i = i + 1
  }
  acc
}
```

### 练习 5-13

- 写一个不可变版本与一个可变版本的“过滤 + 映射”组合，并记录差异点。

---

## 5.14 状态模式：累加器、缓存、计数器

在实际开发中，有几种常见的模式专门用于管理可变状态。识别并规范化这些模式，可以避免代码变成“面条式”的混乱逻辑。

1.  **累加器（Accumulator）**：通常在循环中使用，用于收集结果（如求和、构建列表）。
2.  **缓存（Cache/Memoization）**：用于存储昂贵计算的结果。如果输入相同，直接返回缓存值，避免重复计算。这通常需要一个可变的字典或数组。
3.  **计数器（Counter）**：用于生成唯一 ID 或统计事件发生次数。
    建议将这些状态集中管理，不要让 `mut` 变量散落在业务逻辑的各个角落。

示例缓存（简化）：

```moonbit expr
fn memo_add_one() -> (Int) -> Int {
  // seen 用于缓存已计算过的结果，避免重复计算
  let mut seen = [] : Array[Int]

  fn(x){
    // 实际逻辑应检查 x 是否在 seen 中
    // 若 x in seen 返回结果；否则计算并记录
    x + 1
  }
}
```

### 练习 5-14

- 实现一个简单“出现次数统计”函数：遍历数组返回 (值, 次数) 元组数组（可用可变或不可变两种写法）。

---

## 5.15 配置与 `const` 组织策略

随着项目变大，散落在代码各处的数字和字符串字面量会成为维护的噩梦。良好的工程实践是将这些值提取为 `const`。

对于大型项目，建议采用分层策略：

1.  **局部常量**：只在某个函数内部使用的常量，定义在函数顶部。
2.  **模块常量**：在整个模块（文件）通用的常量，定义在文件顶部。
3.  **全局配置**：涉及整个系统的配置（如超时时间、API 地址），建议放入专门的 `config` 包或文件中。
    命名上，使用层级前缀（如 `HTTP_TIMEOUT_MS`）能进一步清晰含义。

### 练习 5-15

- 把你在前面示例里出现的数字替换为 `const`，并说明含义。

---

## 5.16 代码异味（Smells）检查表

“代码异味”是指那些虽然不报错，但暗示代码设计可能存在问题的迹象。在变量使用方面，常见的异味包括：

1.  **过长的 `mut` 块**：如果一个函数里有几十行代码都在修改同一个 `mut` 变量，说明逻辑可能太复杂，需要拆分。
2.  **变量生命周期过长**：在函数开头定义变量，却只在函数末尾使用。这增加了阅读者的心理负担，应尽可能缩短变量的定义与使用距离。
3.  **命名含糊**：使用 `data`, `info`, `obj` 这种万能词，完全没有传达出变量的业务含义。
4.  **作用域泄漏**：本该在 `if` 块里使用的临时变量，却定义在了 `if` 外面。

### 练习 5-16

- 针对任一已有示例做“异味扫描”列 3 点并给出改良方案。

---

## 5.17 挑战练习

1. 设计一个“任务队列”结构的原型：新增任务、完成任务、统计剩余（使用可变/不可变两种实现）。
2. 编写一个闭包工厂：`make_limiter(limit : Int)` 返回函数，每次调用递增计数，超过限制返回错误枚举。
3. 写一个函数自动为一组字符串生成递增编号（使用 shadowing 与使用 `mut` 两版）。
4. 编写一个“批处理”模拟：聚合输入、处理、输出结果字符串（分层 + 命名规范）。
5. 创建你的“变量命名清单”至少 8 条规则并套用到两段旧代码示例中。

> 目标：通过多角度练习内化“可变性最小化”与“清晰生命周期”理念。
