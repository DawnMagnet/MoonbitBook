# 第 6 章 变量、常量与作用域（安全与风格）

目标：理解“绑定”与“可变性”在 MoonBit 中的语义；学会选择 `let`、`mut`、`const`；避免无意修改、名称冲突与作用域泄漏；建立良好命名与生命周期习惯。

---

## 6.1 绑定是什么？

绑定（binding）就是“给一个值起名字”。形式：`let 名字 = 表达式`。默认不可变，利于推理。

```moonbit expr
fn main {
  let x = 5
  let y = x + 2
  println(y)
}
```

这里 `x` 与 `y` 只是值的“引用名字”，不代表可更改的盒子。

### 练习 6-1

- 写两个不可变绑定：`base = 10`、`height = 5`，再计算面积并打印。

---

## 6.2 可变绑定：`mut`

仅在确实需要改变值时使用：

```moonbit expr
fn main {
  let mut count = 0
  count = count + 1
  count = count + 5
  println(count)
}
```

误区：过度使用 `mut` 会让代码难以阅读（谁修改了值？何时？）。若只是“基于旧值计算新值”，可新建绑定而非原地更改。

### 练习 6-2

- 将一个使用多次 `mut` 自增的代码改写为不可变链式计算（新建多个 `stepX` 绑定）。

---

## 6.3 常量：`const`

编译期即可确定，不会随运行时变化。

```moonbit expr
const PI = 3.14159
const DEFAULT_SIZE = 100
fn main { println(PI); println(DEFAULT_SIZE) }
```

用途：配置值、尺寸、固定字符串。命名建议全大写下划线：`MAX_LIMIT`。不要把需要动态计算的结果放入 const（编译器会报无法确定）。

### 练习 6-3

- 定义一个常量 `GREETING` 并在函数中引用。

---

## 6.4 类型注解的好处

虽然可推断，但显式注解能：

- 作为“文档”提示意图
- 在复杂表达式中防止误推断

```moonbit expr
fn main {
  let id : Int = 42
  let name : String = "moon"
  println(id)
}
```

### 练习 6-4

- 去掉类型注解再运行，观察是否行为一致，再加回注解。

---

## 6.5 作用域（Scope）与生命周期

作用域：变量可见的代码区域。进入 `{}` 新块时可以创建同名新绑定（shadowing）。

```moonbit expr
fn main {
  let x = 10
  println(x)        // 10
  {
    let x = 99      // shadow 外层 x
    println(x)      // 99
  }
  println(x)        // 10 外层未受影响
}
```

生命周期直觉：作用域结束后名字失效（被回收或不再可用）。不要在外层使用内层局部临时变量。

### 练习 6-5

- 写嵌套两层块，各层定义 `value` 不同数值并分别打印。

---

## 6.6 Shadowing vs Mutation

Shadowing：新的不可变绑定覆盖旧名；Mutation：原地修改同一个变量。

```moonbit expr
fn main {
  let x = 5
  let x = x + 1    // shadowing，新值 6
  println(x)       // 6
  let mut y = 5
  y = y + 1        // mutation，新值 6
  println(y)
}
```

如何选择：

- 逻辑上“值的一次转换” → 用 shadowing 表达“阶段性新值”。
- 需要在循环或闭包内累积状态 → 用 mutation。

### 练习 6-6

- 用 shadowing 把一个初始字符串多次加工（追加子串），不使用 `mut`。

---

## 6.7 命名与可读性

建议：

- 语义化：`total_price` > `tp`。
- 使用英文或通用缩写，避免魔法字母。
- 布尔变量用肯定陈述：`is_valid`, `has_error`。
- 临时变量可短，但避免过度：`i`、`idx` 在局部循环可接受。

反例：

```moonbit expr
fn bad {
  let a = 100    // a 是什么？
  let b = a + 5  // b 又是什么？
  println(b)
}
```

改良：

```moonbit expr
fn good {
  let base_price = 100
  let final_price = base_price + 5
  println(final_price)
}
```

### 练习 6-7

- 重写一个你写过的示例，把所有命名改得更清晰。

---

## 6.8 常见错误与排查

错误：修改不可变绑定。

```
let x = 5
x = 6  // 报错：immutable
```

解决：改为 `let mut x = 5` 或使用 shadowing：`let x = x + 1`。

错误：使用超出作用域的变量。

```
{
  let inner = 10
}
println(inner) // 报错：未定义
```

解决：把需要的值返回或提升作用域。

错误：命名冲突导致读错含义 → 分清层次或改名。

### 练习 6-8

- 制造一个不可变修改错误并修复；制造一个作用域错误并修复。

---

## 6.9 综合示例：统计并格式化

```moonbit expr
fn main {
  let numbers = [1,2,3,4]
  let mut sum = 0
  for n in numbers { sum = sum + n }
  let average = sum / numbers.length()
  println("sum=\{sum}, avg=\{average}")
}
```

改进（减少 mutation）：

```moonbit expr
fn main {
  let numbers = [1,2,3,4]
  let sum = numbers.fold(0, fn(acc, n){ acc + n })
  let avg = sum / numbers.length()
  println("sum=\{sum}, avg=\{avg}")
}
```

### 练习 6-9 综合

- 对比两个实现风格——写出你偏好的理由（可写在注释或独立说明）。

---

## 6.10 小结

掌握：不可变默认、`mut` 仅在需要时用、`const` 编译期、作用域与 shadowing 的语义、命名与排错基本方法。下一章我们进入控制流：如何“分支、循环、选择”。

---

## 6.11 自测

1. 写一个函数内部使用 shadowing 连续规范化字符串（去空格 → 小写 → 追加后缀）。
2. 写一个循环累加示例，用 `mut` 版与 fold 版各一次。
3. 写一段错误示例并在注释中解释它的错误与修复方式。

（答案在 `appendix/answers.md`）

---

## 6.12 闭包捕获与状态语义

当闭包捕获外部变量：

- 捕获不可变：只读取，不修改（推荐）。
- 捕获可变：允许内部修改 → 增加推理复杂度。
  避免在多个闭包共享同一个可变变量同时修改；封装为工厂函数返回单一“控制器”闭包更安全。

示例：

```moonbit expr
fn make_counter(start : Int) -> () -> Int {
  let mut c = start
  fn(){ c = c + 1; c }
}
```

### 练习 6-12

- 设计一个捕获数组的闭包：每次调用追加一个值并返回当前长度；再写纯函数版本（返回新数组）比较。

---

## 6.13 不可变 vs 性能权衡

不可变带来安全与可读；在极端性能场景（大型循环更新）可能创建较多中间值：

- 策略：先写不可变，性能确认后再聚焦热点改为局部 `mut`。
- 局部可变：限制作用域，仅在块内部声明 `let mut`，返回最终不可变结果。

示例对比：

```moonbit expr
fn build_seq_pure(n : Int) -> Array[Int] { /* 伪：假设 map 构造 */ [1,2,3] }
fn build_seq_mut(n : Int) -> Array[Int] {
  let mut acc = [] : Array[Int]
  let mut i = 0
  while i < n { /* acc.push(i) */ i = i + 1 }
  acc
}
```

### 练习 6-13

- 写一个不可变版本与一个可变版本的“过滤 + 映射”组合，并记录差异点。

---

## 6.14 状态模式：累加器、缓存、计数器

常见可变模式：

- 累加器：`mut total` 在循环中更新。
- 缓存：字典或数组存储已计算结果。
- 计数器：闭包内部 `mut count`。
  建议：集中定义，避免分散在多函数里。

示例缓存（简化）：

```moonbit expr
fn memo_add_one() -> (Int) -> Int {
  let mut seen = [] : Array[Int]
  fn(x){ /* 若 x in seen 返回结果；否则计算并记录 */ x + 1 }
}
```

### 练习 6-14

- 实现一个简单“出现次数统计”函数：遍历数组返回 (值, 次数) 元组数组（可用可变或不可变两种写法）。

---

## 6.15 配置与 `const` 组织策略

集中：

- 将所有编译期常量放置单独文件（如 `config.mbt`）或顶部区域。
- 分层命名：`DEFAULT_TIMEOUT_MS`、`MAX_RETRIES`。
  避免：在业务逻辑中散落“魔法数字”。

### 练习 6-15

- 把你在前面示例里出现的数字替换为 `const`，并说明含义。

---

## 6.16 代码异味（Smells）检查表

- 大量 `mut`：是否可改写为不可变链式？
- 变量生命周期太长：是否能缩小到更小的块？
- 名称含糊：`data`, `info` → 不传达语义。
- 作用域泄漏：仅在局部使用的绑定却提升到外层。
- 重复的初始化模式：可抽成函数。

### 练习 6-16

- 针对任一已有示例做“异味扫描”列 3 点并给出改良方案。

---

## 6.17 挑战练习

1. 设计一个“任务队列”结构的原型：新增任务、完成任务、统计剩余（使用可变/不可变两种实现）。
2. 编写一个闭包工厂：`make_limiter(limit : Int)` 返回函数，每次调用递增计数，超过限制返回错误枚举。
3. 写一个函数自动为一组字符串生成递增编号（使用 shadowing 与使用 `mut` 两版）。
4. 编写一个“批处理”模拟：聚合输入、处理、输出结果字符串（分层 + 命名规范）。
5. 创建你的“变量命名清单”至少 8 条规则并套用到两段旧代码示例中。

> 目标：通过多角度练习内化“可变性最小化”与“清晰生命周期”理念。
