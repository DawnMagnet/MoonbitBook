# 第 6 章 控制流（写清楚逻辑，修正版）

目标：掌握条件分支、匹配（模式）、多种循环形式与范围遍历；建立“表达式”风格（if/match 有值）；避免深度嵌套与可读性下降；练习编写清晰的逻辑函数。

---

## 6.1 为什么需要控制流？

没有控制流，程序只能顺序执行。控制流让程序“根据条件采取不同路径”或“重复执行某些操作”。核心问题：在什么条件下，做什么事，做多少次。

---

## 6.2 if 表达式（有值）

```moonbit expr
fn classify(n : Int) -> String {
  if n > 0 { "positive" } else if n == 0 { "zero" } else { "negative" }
}
fn main { println(classify(0)); println(classify(-3)) }
```

要点：所有分支必须返回同类型的值（此例都是 `String`）。`if` 返回的值可直接绑定或作为函数返回值。

### 常见误区

- 在一个分支返回字符串，另一个分支漏写返回值（编译器报类型不一致）。
- 把 if 写成“动作”而非“产生值”，导致额外变量冗余。

### 练习 6-1

- 写 `abs(n : Int) -> Int` 使用 if 表达式。

---

## 6.3 else if 链与可读性

层数过多：考虑枚举 + match 替代。

```moonbit expr
fn grade(score : Int) -> String {
  if score >= 90 { "A" } else if score >= 80 { "B" } else if score >= 70 { "C" } else if score >= 60 { "D" } else { "F" }
}
```

### 练习 6-2

- 重写 `grade` 用枚举 `Grade {A B C D F}` + match（见后文）。

---

## 6.4 match 表达式（模式匹配）

用于对“离散状态”或结构进行分派。示例：

```moonbit expr
enum Weather { Sunny Rainy Cloudy Snowy }
fn advise(w : Weather) -> String {
  match w {
    Rainy => "Read"
    Cloudy => "Think"
    Snowy => "Play"
    Sunny => "Walk"
  }
}
```

### 练习 6-3

- 定义枚举 `TrafficLight { Red Yellow Green }` 写函数返回下一个状态（循环）。

---

## 6.5 循环：while

```moonbit expr
fn countdown(start : Int) {
  let mut s = start
  while s > 0 { println(s); s = s - 1 }
  println("GO!")
}
```

```moonbit expr
fn demo_break_continue() {
  let mut i = 5
  while i > 0 {
    i = i - 1
    if i == 3 { continue }
    if i == 1 { break }
    println(i)
  }
}
```

### 练习 6-4

- 写一个 while 循环找出第一个能被 7 整除的数字（从 1 起），并打印。

---

## 6.6 C 风格 for 循环

```moonbit expr
fn demo_c_for() {
  for i = 0; i < 3; i = i + 1 { println(i) }
  for i = 0, j = 3; i < j; i = i + 1, j = j - 1 { println("i=\{i}, j=\{j}") }
}
```

适合需要索引精细控制的场景。多变量初始化可并行推进两个指针。

### 练习 6-5

- 用 C 风格 for 写一个双指针求数组最小/最大值（不使用内建函数）。

---

## 6.7 for..in 与范围

```moonbit expr
fn demo_range_basic() {
  for x in [1,2,3] { println(x) }
  for i in 0..=3 { println(i) } // 0,1,2,3
}
```

带索引：

```moonbit expr
fn demo_index_iter() {
  let fruits = ["apple","banana"]
  for idx, f in fruits { println("\{idx}: \{f}") }
}
```

范围语义：`a..<b` 左闭右开；`a..=b` 左闭右闭。选哪种取决于遍历元素个数意图。

### 练习 6-6

- 使用范围生成前 10 个平方并打印（索引或直接值两种方式）。

---

## 6.8 综合：求和与过滤

```moonbit expr
fn sum(arr : Array[Int]) -> Int {
  let mut s = 0
  for n in arr { s = s + n }
  s
}
fn sum_fold(arr : Array[Int]) -> Int { arr.fold(0, fn(acc,n){ acc + n }) }
fn filter_even(arr : Array[Int]) -> Array[Int] { arr.filter(n => n % 2 == 0) }
```

对比：命令式 vs 函数式风格。视团队习惯选择，一致最重要。

### 练习 6-7

- 写 `count_positive(arr : Array[Int]) -> Int` 不使用额外数组；再写 `count_positive2` 使用过滤后取长度对比。

---

## 6.9 分支封装示例

```moonbit expr
enum Grade { A B C D F }
fn grade_of(score : Int) -> Grade {
  if score >= 90 { A } else if score >= 80 { B } else if score >= 70 { C } else if score >= 60 { D } else { F }
}
```

进一步：可把范围逻辑封装为函数减少噪音。

### 练习 6-8

- 将 `grade_of` 拆成两个函数：判断区间 + 组装枚举，比较可读性。

---

## 6.10 避免深嵌套

反例：

```moonbit expr
fn bad(n : Int) -> String {
  if n > 0 {
    if n % 2 == 0 { "positive even" } else { "positive odd" }
  } else { "non-positive" }
}
```

改良：

```moonbit expr
fn good(n : Int) -> String {
  if n <= 0 { return "non-positive" }
  if n % 2 == 0 { "positive even" } else { "positive odd" }
}
```

思路：早退出 / 分支拆函数，让每个路径简单。

### 练习 6-9

- 重写 `bad` 风格函数使嵌套层级最多 1。

---

## 6.11 小结

你已掌握：if（表达式）、match、while、C for、for..in、范围、索引 + 值遍历、过滤/折叠、分支重构。下一章（第 7 章）我们会扩展函数主题：闭包性能、尾递归与高阶模式。

---

## 6.12 自测

1. 写一个函数：接收数组和阈值，返回所有大于阈值元素的新数组（纯函数）。
2. 写一个函数：计算数组中第一个重复出现的元素（使用循环 + break）。
3. 写一个枚举 describing 操作状态（Ok Error Pending），写 match 返回提示文本。

（答案见 `appendix/answers.md`）

---

## 6.13 match 进阶：守卫与默认（若支持）

若语言支持“守卫”可用于更细粒度分类；若暂未支持，可用嵌套 `if` + `match`。

```moonbit expr
enum Score { Val(Int) }
fn level(s : Score) -> String {
  match s {
    Val(x) => if x >= 90 { "A" } else if x >= 80 { "B" } else { "Other" }
  }
}
```

### 练习 6-10

- 将一段 if 链改写为单个 match + 内部条件组合。

---

## 6.14 循环不变量与推理

循环不变量：在每次迭代前后都成立的条件（帮助验证正确性）。示例：求和过程中“不变量”：`partial_sum == 原数组前 i 项之和`。

### 练习 6-11

- 为任一 while 或 for 循环写一条不变量说明并验证逻辑。

---

## 6.15 从命令式到函数式：折叠与组合

转换原则：

- 只读遍历 + 累积 → `fold`
- 简单过滤 + 映射 → 链式 `filter` + `map`
- 能否将多个条件组合为表达式返回值而非多变量更新？

```moonbit expr
fn count_positive_loop(a : Array[Int]) -> Int {
  let mut c = 0
  for n in a { if n > 0 { c = c + 1 } }
  c
}
fn count_positive_fold(a : Array[Int]) -> Int {
  a.fold(0, fn(acc,n){ if n > 0 { acc + 1 } else { acc } })
}
```

### 练习 6-12

- 把一个双循环累积逻辑改成单次 fold（如：统计正偶数数量）。

---

## 6.16 错误传播与控制流

```moonbit expr
enum Read { Ok(String) Err(String) }
fn read_and_process() -> Read {
  let r = Read::Ok("data")
  match r { Ok(d) => Ok(d + "!") Err(e) => Err(e) }
}
```

### 练习 6-13

- 设计一个链式 3 步处理（读取 → 解析 → 格式化），每步可能失败，使用枚举组合逻辑。

---

## 6.17 常用小算法模式

1. 线性搜索：遍历数组查找目标。
2. 分区：按条件拆成两个数组。
3. 去重：维护已见集合（若缺集合结构可用嵌套循环）。

```moonbit expr
fn find_first(a : Array[Int], target : Int) -> Option[Int] {
  let mut i = 0
  while i < a.length() {
    if a[i] == target { return Some(i) }
    i = i + 1
  }
  None
}
```

### 练习 6-14

- 实现 `partition_even`。
- 实现顺序保持的简单去重。

---

## 6.18 性能与控制结构选择

选择结构时考虑：索引 → for/while；仅元素 → for..in；分类 → match；简单条件 → if。

### 练习 6-15

- 重写一个 while 版本为 for..in + 范围，比较可读性与错误风险。

---

## 6.19 挑战练习

1. 数组统计报告（最小/最大/平均）。
2. 有限状态机处理输入序列。
3. 窗口求和（循环与函数式两版）。
4. 深嵌套重构对比行数。
5. 总结 3 个常见控制流错误及避免策略。

> 目标：通过在不同结构间转换提升"选择最合适控制流"能力。
