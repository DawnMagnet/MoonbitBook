# 第 4 章 函数与程序结构

本章目标：彻底掌握 MoonBit 中函数的定义、调用、参数形式（普通参数、带标签参数、可选参数与默认值）、返回值规则、局部/匿名/箭头函数、闭包、部分应用与代码组织风格。我们不假设你已经会其它语言的函数概念；所有术语都重新解释。请边看边敲，每个代码块都可以单独运行。

---

## 4.1 为什么需要函数？

直觉：没有函数，代码会像一条长长的流水账，难以阅读、复用、测试。函数让我们可以把“逻辑片段”打包，给它名字（语义），并在需要时调用。函数同时是：

- 可重复执行的代码单元（复用性）
- 拥有输入（参数）与输出（返回值）的“转换器”
- 组织复杂程序的最小结构砖块

数学类比：数学里的 f(x)=x+1 与编程里的 `fn inc(x : Int) -> Int { x + 1 }` 极其相似 —— 输入一个 `x`，得到一个新值。

---

## 4.2 基本函数定义与调用

语法最小形式：

```moonbit expr
fn name(param1 : Type1, param2 : Type2) -> ReturnType {
  <函数体，最后一个表达式的值即返回值>
}
```

如果没有输入参数，则省略括号内内容，但是返回指类型仍然是必要的。

### 示例：最小与带返回值

```moonbit expr
fn greet() -> Unit {
  println("Hello, MoonBit!")  // 返回 Unit
}

fn add(x : Int, y : Int) -> Int {
  x + y   // 最后一个表达式是返回值
}

fn main {
  greet()
  let s = add(3, 4)
  println(s)
}
```

要点：

- 不写 `return`；最后一个表达式的值自动成为返回值。
- 无参函数调用时可以写 `greet()` 或仅写 `greet`（风格上推荐加括号保持一致性）。

### 初学者常见误区

- 把“打印结果”误当成“函数返回值”——打印只是副作用，返回值要看函数体最后的表达式。
- 写了多余的 `return`（若语言暂未支持或不需要），保持表达式风格即可。

### 练习 4-1

1. 写一个函数 `square(n : Int) -> Int` 返回 `n*n`；在 `main` 中调用并打印 5 的平方。
2. 写一个函数 `hello(name : String) -> String` 返回拼好的问候语，不打印，交给调用者打印。

---

## 4.3 `main` 与 `init` 特殊入口

- `main`：程序唯一入口，无参数，无返回值，用来启动整体流程。
- `init`：可有多个，在 `main` 之前执行，用于资源或状态初始化。不要依赖多个 `init` 的执行顺序。

```moonbit expr
fn init() -> Unit { println("[init] setup...") }
fn init() -> Unit { println("[init] second init...") }
fn main() -> Unit { println("[main] running") }
```

图示（概念）：

```
  init1 → init2 → ... → main → 结束
```

库（供别人调用的包）中不可以写 `main`；可执行程序必须有且仅有一个 `main`。

### 练习 4-2

- 写两个 `init`（将其顺序打乱，或者放在`main`后面），分别打印不同信息，以及一个 `main`。运行观察顺序（顺序不保证，记录你的实际输出）。

---

## 4.4 参数与类型注解

形式：`x : Int` 表示“x 的类型是 Int”。编译器据此做类型检查。

```moonbit expr
fn concat(a : String, b : String) -> String { a + b }
fn main { println(concat("A", "B")) }
```

省略返回类型：若返回 `Unit` 可不写；但为可读性，复杂函数建议显式标注返回类型。

---

## 4.5 带标签的参数（命名参数）

标签语法：`name~ : Type`。调用时用 `name="Alice"`。

优势：不需要记住参数位置顺序；读调用代码即知每个值的意义。

```moonbit expr
fn create_user(name~ : String, age~ : Int, email~ : String) -> String {
  "User(name: \{name}, age: \{age}, email: \{email})"
}

fn main {
  let u1 = create_user(age=30, name="Alice", email="alice@example.com")
  let name = "Bob"
  let age = 18
  let email = "bob@example.com"
  let u2 = create_user(name~, age~, email~) // 变量名与标签相同的简写
  println(u1)
  println(u2)
}
```

注意：把顺序写错不影响结果（因为按标签匹配），但若某个标签漏写或拼错会报错；仔细核对。

用此种方式定义的函数，调用时**必须**使用标签。输入参数的顺序可以任意。但是标签名称必须正确无误，如果你当前定义了一个名称与标签相同的变量，可以使用简写形式 `name~` 来传递该变量的值。

```moonbit expr
let u2 = create_user(name~, age~, email~) // 变量名与标签相同的简写
```

当然你也可以使用完整形式：

```moonbit expr
let u2 = create_user(name=name, age=age, email=email)
```

### 练习 4-3

- 设计一个 `make_point(x~ : Int, y~ : Int) -> String`，在调用时交换书写顺序验证不受影响。

---

## 4.6 可选参数与默认值

可选参数的意思是调用时可以省略该参数（但实际上这个参数肯定是要传入的），函数内部会收到一个 `Option` 类型（`Some(value)` 或 `None`）。默认值参数则是在调用时省略该参数时，函数会使用预设的默认值，如果没有预设默认值则使用`None`。

注意：只有带标签参数才能使用可选与默认值。
两种方式：

1. 直接写默认值：`greeting? : String = "Hello"`。（注意此处`~` 变为`?`）
2. 使用 `?` 语法：`width? : Int` 自动成为 `Option[Int]`；调用省略则为 `None`，传值自动打包为 `Some(value)`。

```moonbit expr
fn greet(name~ : String, greeting? : String = "Hello") -> String {
  "\{greeting}, \{name}!"
}

fn create_rectangle(width? : Int, height? : Int) -> String {
  let w = match width {
    Some(v) => v
    None => 10
  }
  let h = match height {
    Some(v) => v
    None => 10
  }
  "Rect \{w}x\{h}"
}

fn main {
  println(greet(name="Alice"))
  println(greet(name="Bob", greeting="Hi"))
  println(create_rectangle())
  println(create_rectangle(width=20))
  println(create_rectangle(width=20, height=5))
}
```

设计选择：使用 `?` 参数时内部必须处理 `Option`；若只是单纯默认值，直接用带默认的标签更简单。这种设计让调用者更清晰地知道哪些参数是可选的，同时也让函数实现者有更多灵活性去处理缺省情况。相比于`C/C++`中的指针或`Java`中的`null`，这种方式更安全，避免了空指针异常的问题。

### 练习 4-4

- 写 `area(width? : Int, height? : Int)` 默认 10，返回字符串 `"WxH"`。
- 写 `greet2(name~ : String, punctuation~ : String = ".")`，再测试省略与提供不同标点。

---

## 4.7 部分应用函数（Partial Application）

有的时候我们想把一个多参数函数“变成”一个少参数函数，在数论中称为“柯里化”（Currying）。MoonBit 支持通过部分应用来实现这一点。一般的高阶函数式编程语言都会支持这种特性。这种情况下，看似调用了某个函数，但实际上这个函数并没有被立即调用，而是返回了一个新的函数，这个新函数将等待剩余的参数。

用下划线 `_` 作为占位符固定部分参数，得到新函数：

```moonbit expr
fn add(x : Int, y : Int) -> Int { x + y }
fn main {
  let add10 = add(10, _)
  println(add10(5))  // 15
}
```

再看多参数：

```moonbit expr
fn multiply(x : Int, y : Int, z : Int) -> Int { x * y * z }
fn main {
  let times2and3 = multiply(_, 2, 3)
  println(times2and3(4)) // 24
}
```

部分应用函数也可以作用于**带标签参数**，唯一的区别是得将这个标签写上，如下所示：

```moonbit expr
fn add(x : Int, y? : Int = 10) -> Int {
  return x + y
}

fn main {
  let add10 = add(10, y=_)
  println(add10(5)) // 15
}
```

### 练习 4-5

- 用部分应用函数写一个 `inc`（基于 `add`）。
- 基于 `multiply` 构造一个函数固定后两个参数为 5 和 6，再调用测试。

---

## 4.8 匿名函数与箭头函数

匿名函数是一种特殊的函数，它没有名字（但是可以作为一个变量），通常用于临时场合，比如作为参数传递给高阶函数。MoonBit 支持两种形式的匿名函数：

匿名函数：`fn(x) { x * 2 }`；箭头函数：`x => x * 2` 更简洁。

```moonbit expr
fn main {
  let nums = [1, 2, 3]
  let doubled = nums.map(fn(n) { n * 2 })
  let squared = nums.map(n => n * n)
  println(doubled)
  println(squared)
}
```

> 在该实例中，`map` 函数接受一个函数作为参数，并对数组中的每个元素应用该函数。我们使用了匿名函数和箭头函数来实现这一点。这其实是包含在标准库中的数组部分的函数，任意数组都可以调用 `map` 方法。

选择：简单单表达式用箭头；多语句或需要局部绑定，用块状 `fn(...) { ... }`。

匿名函数还可以作为变量赋值：

```moonbit expr
fn main {
  let add = fn(x : Int, y : Int) -> Int { x + y }
  let result = add(3, 4)
  println(result)
}
```

箭头函数作为匿名函数的简写形式：

```moonbit expr
fn main {
  let add = (x, y) => x + y
  let result = add(3, 4)
  println(result)
}
```

在匿名函数中，不写返回类型时，编译器会根据函数体自动推断返回类型，如果不能推断则会报错。

如下的程序是无法编译通过的

```moonbit expr
fn main {
  let add = (x, y) => x + y
}
```

因为没有人使用 `add` 函数，编译器无法推断出 `x` 和 `y` 的类型，从而导致编译错误。你可以通过调用 `add` 函数并传入具体的参数来解决这个问题。

### 练习 4-6

- 用匿名函数与箭头函数各自实现把 `[1,2,3]` 转成其立方。

---

## 4.9 闭包

闭包是一类特殊的匿名函数，它可以“捕获”其定义环境中的变量，从而在函数体内使用这些变量。闭包允许我们创建具有状态的函数，这在很多场景下非常有用。

在当前环境中，`create_counter` 定义了一个闭包 `fn() { c = c + 1; c }`，它捕获了外部变量 `c`。每次调用返回的函数时，都会访问并修改这个捕获的变量 `c`。

```moonbit expr
fn create_counter(start : Int) -> () -> Int {
  let mut c = start
  fn() { c = c + 1; c }
}
fn main {
  let counter = create_counter(10)
  println(counter())
  println(counter())
}
```

`c` 在返回后仍存在于闭包环境中。副作用提醒：频繁修改捕获变量会让逻辑难以跟踪；能用纯函数就用纯函数。有捕获的闭包是非常危险的，因为它们会引入隐藏的状态变化，可能导致难以预料的行为。建议仅在必要时使用，并确保理解其工作原理。但有的时候危险与便利是并存的。

### 练习 4-7

- 写一个 `make_adder(base : Int)` 返回 `(Int) -> Int`，每次调用加上 base。

---

## 4.10 高阶函数（HOF）

在每一个函数式编程语言中，高阶函数都是一个重要的概念。高阶函数是指那些**接收函数作为参数**或**返回一个函数作为结果**的函数。通过高阶函数，我们可以实现更抽象、更灵活的代码结构。高阶函数往往需要以匿名函数作为参数传递，在调用高阶函数时，我们可以传入自定义的行为，从而实现不同的功能。例如之前出现过的`map` 函数就是一个典型的高阶函数。

```moonbit expr
fn apply_twice(f : (Int)->Int, x : Int) -> Int { f(f(x)) }
fn add_one(x : Int) -> Int { x + 1 }
fn main { println(apply_twice(add_one, 5)) }
```

价值：把“变化的行为”抽象出去，剩下通用结构。常见在集合处理、管道、策略模式。

### 练习 4-8

- 写 `compose(f : (Int)->Int, g : (Int)->Int) -> (Int)->Int` 返回组合函数。

---

## 4.11 递归与相互递归

递归函数是一类在其定义中调用自身的函数。递归是一种强大的编程技术，允许我们用简洁的方式解决许多问题，尤其是那些可以被分解为更小的子问题的问题。递归函数通常包含两个主要部分：基准情况（base case）和递归情况（recursive case）。基准情况用于终止递归，防止无限循环；递归情况则定义了如何将问题分解为更小的子问题。

我们先用一个简单的例子引入递归：计算阶乘。

阶乘在数学上定义是，对于一个非负整数 n，n!（读作“n 的阶乘”）是所有小于等于 n 的正整数的乘积。特别地，0 的阶乘定义为 1。

那么我们可以获得如下公式

$ n! = n \times (n-1)! \quad \text{当 } n > 0 $

如果我们将阶乘看作一个函数 `factorial(n)`，那么我们发现了一个惊人的事实，即 `factorial(n)` 可以通过调用 `factorial(n-1)` 来计算。这就是递归的核心思想。

```moonbit expr
fn factorial(n : Int) -> Int {
  if n <= 1 {
    1
  } else {
    n * factorial(n - 1)
  }
}

fn main {
  println(factorial(5))
}
```

大家可以通过如下的例子加深对递归的理解：

```moonbit expr
fn f(n: Int) -> Unit {
  if n > 0 {
    println(n)
    f(n - 1)
    println(n)
  }
}
fn main {
  println(f(5))
}
```

递归函数的设计需要注意以下几点：

- **基准情况**：确保递归函数有一个明确的基准情况，以防止无限递归。
- **递归调用**：在递归情况下，确保每次递归调用都使问题规模减小，逐步接近基准情况。
- **性能考虑**：递归可能导致栈溢出，尤其是在递归深度较大的情况下。

风险：深度过大 → 栈溢出；若编译器支持尾递归优化，可把末尾调用改写为“尾位置”。（高级优化细节在第 8 章）

### 练习 4-9

- 写一个递归 `sum_array(arr : Array[Int]) -> Int`（用索引遍历递归）。
- 写一个相互递归判断“奇偶”示例并在 `main` 中测试多个数字。

---

## 4.12 本章小结

你现在掌握：函数定义、`main/init`、标签与可选参数、默认值、部分应用、匿名与箭头函数、闭包、高阶、递归函数。函数是组织程序的核心单元，良好的函数设计能极大提升代码质量。

---

## 4.13 章节自测（建议写在单独文件）

1. 实现一个“斐波那契闭包生成器”：`make_fib() -> () -> Int` 每次调用返回下一个 Fibonacci 数。
2. 用部分应用函数与高阶函数组合，先写 `scale(factor : Int, x : Int) -> Int`，再得到 `scale_by_10`，然后写 `apply_twice` 验证结果。
3. 编写一个安全的除法， `safe_div(x? : Int, y? : Int)` 可选参数默认 1，若除以 0 返回字符串错误说明。

（答案在 `appendix/answers.md`）
