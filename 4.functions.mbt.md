# 第 4 章 函数与程序结构（从入门到规范）

本章目标：彻底掌握 MoonBit 中函数的定义、调用、参数形式（普通参数、带标签参数、可选参数与默认值）、返回值规则、局部/匿名/箭头函数、闭包、部分应用与代码组织风格。我们不假设你已经会其它语言的函数概念；所有术语都重新解释。请边看边敲，每个代码块都可以单独运行。

---

## 4.1 为什么需要函数？

直觉：没有函数，代码会像一条长长的流水账，难以阅读、复用、测试。函数让我们可以把“逻辑片段”打包，给它名字（语义），并在需要时调用。函数同时是：

- 可重复执行的代码单元（复用性）
- 拥有输入（参数）与输出（返回值）的“转换器”
- 组织复杂程序的最小结构砖块

数学类比：数学里的 f(x)=x+1 与编程里的 `fn inc(x : Int) -> Int { x + 1 }` 极其相似 —— 输入一个 `x`，得到一个新值。

---

## 4.2 基本函数定义与调用

语法最小形式：

```moonbit expr
fn name(param1 : Type1, param2 : Type2) -> ReturnType {
  <函数体，最后一个表达式的值即返回值>
}
```

若没有参数，可省略括号；若返回值没有“有意义的内容”，可省略 `-> ReturnType`（编译器视为返回 `Unit`）。

### 示例：最小与带返回值

```moonbit expr
fn greet {
  println("Hello, MoonBit!")  // 返回 Unit
}

fn add(x : Int, y : Int) -> Int {
  x + y   // 最后一个表达式是返回值
}

fn main {
  greet()
  let s = add(3, 4)
  println(s)
}
```

要点：

- 不写 `return`；最后一个表达式的值自动成为返回值。
- 无参函数调用时可以写 `greet()` 或仅写 `greet`（风格上推荐加括号保持一致性）。

### 初学者常见误区

- 把“打印结果”误当成“函数返回值”——打印只是副作用，返回值要看函数体最后的表达式。
- 写了多余的 `return`（若语言暂未支持或不需要），保持表达式风格即可。

### 练习 4-1

1. 写一个函数 `square(n : Int) -> Int` 返回 `n*n`；在 `main` 中调用并打印 5 的平方。
2. 写一个函数 `hello(name : String) -> String` 返回拼好的问候语，不打印，交给调用者打印。

---

## 4.3 `main` 与 `init` 特殊入口

- `main`：程序唯一入口，无参数，无返回值，用来启动整体流程。
- `init`：可有多个，在 `main` 之前执行，用于资源或状态初始化。不要依赖多个 `init` 的执行顺序。

```moonbit expr
fn init { println("[init] setup...") }
fn init { println("[init] second init...") }
fn main { println("[main] running") }
```

图示（概念）：

```
  init1 → init2 → ... → main → 结束
```

库（供别人调用的包）中不写 `main`；可执行程序必须有且仅有一个 `main`。

### 练习 4-2

- 写两个 `init`，分别打印不同信息，以及一个 `main`。运行观察顺序（顺序不保证，记录你的实际输出）。

---

## 4.4 参数与类型注解

形式：`x : Int` 表示“x 的类型是 Int”。编译器据此做类型检查。

```moonbit expr
fn concat(a : String, b : String) -> String { a + b }
fn main { println(concat("A", "B")) }
```

省略返回类型：若返回 `Unit` 可不写；但为可读性，复杂函数建议显式标注返回类型。

---

## 4.5 带标签的参数（命名参数）

标签语法：`name~ : Type`。调用时用 `name="Alice"`。

优势：不需要记住参数位置顺序；读调用代码即知每个值的意义。

```moonbit expr
fn create_user(name~ : String, age~ : Int, email~ : String) -> String {
  "User(", name, ", ", age.to_string(), ", ", email, ")"
}

fn main {
  let u1 = create_user(age=30, name="Alice", email="alice@example.com")
  let name = "Bob"
  let age = 18
  let email = "bob@example.com"
  let u2 = create_user(name~, age~, email~)  // 变量名与标签相同的简写
  println(u1)
  println(u2)
}
```

误区：把顺序写错不影响结果（因为按标签匹配），但若某个标签漏写或拼错会报错；仔细核对。

### 练习 4-3

- 设计一个 `make_point(x~ : Int, y~ : Int) -> String`，在调用时交换书写顺序验证不受影响。

---

## 4.6 可选参数与默认值

两种方式：

1. 直接写默认值：`greeting~ : String = "Hello"`。
2. 使用 `?` 语法：`width? : Int` 自动成为 `Option[Int]`；调用省略则为 `None`，传值自动打包为 `Some(value)`。

```moonbit expr
fn greet(name~ : String, greeting~ : String = "Hello") -> String {
  "\{greeting}, \{name}!"
}

fn create_rectangle(width? : Int, height? : Int) -> String {
  let w = match width { Some(v) => v  None => 10 }
  let h = match height { Some(v) => v None => 10 }
  "Rect \{w}x\{h}"
}

fn main {
  println(greet(name="Alice"))
  println(greet(name="Bob", greeting="Hi"))
  println(create_rectangle())
  println(create_rectangle(width=20))
  println(create_rectangle(width=20, height=5))
}
```

设计选择：使用 `?` 参数时内部必须处理 `Option`；若只是单纯默认值，直接用带默认的标签更简单。

### 练习 4-4

- 写 `area(width? : Int, height? : Int)` 默认 10，返回字符串 `"WxH"`。
- 写 `greet2(name~ : String, punctuation~ : String = ".")`，再测试省略与提供不同标点。

---

## 4.7 部分应用（Partial Application）

用下划线 `_` 作为占位符固定部分参数，得到新函数：

```moonbit expr
fn add(x : Int, y : Int) -> Int { x + y }
fn main {
  let add10 = add(10, _)
  println(add10(5))  // 15
}
```

再看多参数：

```moonbit expr
fn multiply(x : Int, y : Int, z : Int) -> Int { x * y * z }
fn main {
  let times2and3 = multiply(_, 2, 3)
  println(times2and3(4)) // 24
}
```

常见误区：误以为 `_` 是“忽略”参数；其实它只是未来要补上的位置。

### 练习 4-5

- 用部分应用写一个 `inc`（基于 `add`）。
- 基于 `multiply` 构造一个函数固定后两个参数为 5 和 6，再调用测试。

---

## 4.8 匿名函数与箭头函数

匿名函数：`fn(x) { x * 2 }`；箭头函数：`x => x * 2` 更简洁。

```moonbit expr
fn main {
  let nums = [1,2,3]
  let doubled = nums.map(fn(n){ n*2 })
  let squared = nums.map(n => n*n)
  println(doubled)
  println(squared)
}
```

选择：简单单表达式用箭头；多语句或需要局部绑定，用块状 `fn(...) { ... }`。

### 练习 4-6

- 用匿名函数与箭头函数各自实现把 `[1,2,3]` 转成其立方。

---

## 4.9 闭包（捕获环境）

闭包：返回的函数“记住”它创建时的外部变量。

```moonbit expr
fn create_counter(start : Int) -> () -> Int {
  let mut c = start
  fn() { c = c + 1; c }
}
fn main {
  let counter = create_counter(10)
  println(counter())
  println(counter())
}
```

`c` 在返回后仍存在于闭包环境中。副作用提醒：频繁修改捕获变量会让逻辑难以跟踪；能用纯函数就用纯函数。

### 练习 4-7

- 写一个 `make_adder(base : Int)` 返回 `(Int) -> Int`，每次调用加上 base。

---

## 4.10 高阶函数（HOF）

高阶函数：接收函数或返回函数。示例：

```moonbit expr
fn apply_twice(f : (Int)->Int, x : Int) -> Int { f(f(x)) }
fn add_one(x : Int) -> Int { x + 1 }
fn main { println(apply_twice(add_one, 5)) }
```

价值：把“变化的行为”抽象出去，剩下通用结构。常见在集合处理、管道、策略模式。

### 练习 4-8

- 写 `compose(f : (Int)->Int, g : (Int)->Int) -> (Int)->Int` 返回组合函数。

---

## 4.11 递归与相互递归

递归：函数调用自身；相互递归：两个函数彼此调用。示例：

```moonbit expr
fn factorial(n : Int) -> Int { if n<=1 {1} else { n * factorial(n-1) } }
fn main { println(factorial(5)) }
```

相互递归：

```moonbit expr
fn main {
  letrec even = fn(x){ x==0 || odd(x-1) }
  and odd = fn(x){ x!=0 && even(x-1) }
  println(even(4))
}
```

风险：深度过大 → 栈溢出；若编译器支持尾递归优化，可把末尾调用改写为“尾位置”。（高级优化细节在第 8 章）

### 练习 4-9

- 写一个递归 `sum_array(arr : Array[Int]) -> Int`（用索引遍历递归）。
- 写一个相互递归判断“奇偶”示例并在 `main` 中测试多个数字。

---

## 4.12 代码组织与风格建议

- 函数职责单一：一个函数只做一个清晰的事情；太长就拆分。
- 命名语义化：`compute_total` 好于 `ct`；动词开头（行为）或名词（返回值）分明。
- 先写纯函数（无副作用），后在外层整合 IO/打印。
- INPUT → PROCESS → OUTPUT 结构：入口函数只协调，不堆叠业务细节。

建议分层：

```
main / 入口
  ├─ parse / 读取与解析
  ├─ core  / 纯逻辑（函数、数据转换）
  └─ output / 展示与写出
```

### 练习 4-10 综合

- 构造一个小程序：
  1. `parse_numbers(s : String) -> Array[Int]` （假设用简单分隔）
  2. `sum(arr) -> Int`
  3. `format_result(n : Int) -> String`
     在 `main` 中调用三个函数组合并打印结果。

---

## 4.13 本章小结

你现在掌握：函数定义、`main/init`、标签与可选参数、默认值、部分应用、匿名与箭头函数、闭包、高阶、递归与组织风格。接下来第 5 章将系统化数据类型，帮助你在函数间传递更丰富的信息。

---

## 4.14 章节自测（建议写在单独文件）

1. 实现一个“斐波那契闭包生成器”：`make_fib() -> () -> Int` 每次调用返回下一个 Fibonacci 数。
2. 用部分应用与高阶函数组合，先写 `scale(factor : Int, x : Int) -> Int`，再得到 `scale_by_10`，然后写 `apply_twice` 验证结果。
3. 写 `safe_div(x? : Int, y? : Int)` 可选参数默认 1，若除以 0 返回字符串错误说明。

（答案在 `appendix/answers.md`）

---

## 4.15 参数传递与求值模型（概念深化）

虽然本章展示的调用都“按值”传参，但需要建立几个心智：

- 表达式先求值，结果绑定到形参名字；若是复合结构，其内部元素按语言规则求值（通常是从左到右）。
- 不要依赖“副作用顺序”来做逻辑（例如希望两个参数的打印顺序）——显式拆分到独立语句更清晰。
- 大对象传递：若内部是引用/共享结构，修改后效果可能在调用者可见（视语言是否复制/不可变）。在 MoonBit 中推荐保持数据不可变 + 返回新值。

示例：强调“先求值再进入函数”：

```moonbit expr
fn log_and_inc(x : Int) -> Int { println("arg=\{x}"); x + 1 }
fn main {
  let r = log_and_inc( (10 + 5) ) // 10+5 先求值为 15
  println(r)
}
```

---

## 4.16 纯函数与副作用隔离

副作用：打印、写文件、修改外部可变状态、网络请求。为什么隔离？

- 易测试：纯函数 (same input → same output) 可无需模拟 IO。
- 易推理：不需要跟踪隐藏状态改变。
- 易并发：纯函数可安全并行，不需锁。

策略：

1. 把副作用集中在少量“边缘”函数（如 `main`、`run_cli`）。
2. 内核逻辑（计算、转换）尽量纯；副作用结果用返回值表达。
3. 若必须混合（例如需要日志），考虑传入“记录接口”或先在纯逻辑返回结构，最后统一打印。

对比：

```moonbit expr
// 副作用耦合：难测试
fn total_bad(arr : Array[Int]) -> Int {
  let mut s = 0
  for n in arr { s = s + n; println("adding \{n}") }
  s
}

// 纯逻辑 + 外层打印
fn total_pure(arr : Array[Int]) -> Int {
  arr.fold(0, fn(acc,n){ acc + n })
}
fn main { let nums = [1,2,3]; let t = total_pure(nums); println("total=\{t}") }
```

### 练习 4-11

- 重写一个带打印的函数为纯版本，再包装一个“显示”函数只负责输出。
- 思考：若未来要并发执行一批计算，纯版本与副作用版本哪个更容易？写下原因。

---

## 4.17 错误处理函数模式（基础）

当前尚未展示“异常”机制，可采用返回枚举或 `Option`：

```moonbit expr
enum ParseResult { Ok(Int) Err(String) }
fn parse_digit(s : String) -> ParseResult {
  if s == "0" { Ok(0) } else { Err("unsupported") }
}
fn main {
  let r = parse_digit("1")
  match r { Ok(v)=>println(v) Err(msg)=>println(msg) }
}
```

好处：调用者必须 match，减少忽略错误的情况。函数设计建议：一律返回统一枚举，而非混合使用魔法数字或部分返回值。

### 练习 4-12

- 设计一个 `safe_div(x : Int, y : Int) -> DivResult`（枚举含 Ok(Int)/ZeroDiv）并编写调用演示。

---

## 4.18 API 设计与函数粒度

判断一个函数是否需要拆分：

- 是否出现超过 3 种抽象层级（解析 + 计算 + 展示混在一起）。
- 是否参数列表开始包含说明性注释（表示命名不够或职责过多）。
- 是否难以编写针对该函数的单元测试（说明副作用混入）。

示例拆分：

```moonbit expr
fn parse_line(s : String) -> Array[Int] { /* 简化: 伪实现 */ [1,2] }
fn compute_total(nums : Array[Int]) -> Int { nums.fold(0, fn(a,n){ a+n }) }
fn render_total(t : Int) -> String { "total=\{t}" }
fn main {
  let nums = parse_line("1,2")
  let t = compute_total(nums)
  println(render_total(t))
}
```

### 练习 4-13

- 找出你在本章写的综合练习中可以再拆分的函数，列出原名与拆分后名称列表。

---

## 4.19 性能与微优化（谨慎）

早期过度优化是常见陷阱。函数级别建议：

- 优先正确 + 可读；性能问题用简单基准或真实场景再验证。
- 避免不必要的可变（多次写入可能被误认为热点）。
- 选择合适数据结构（多次随机访问 → 数组；离散状态 → 枚举）。
- 若递归层次深且无尾递归优化，手动改为循环。

微基准（伪示例）：

```moonbit expr
fn sum_loop(a : Array[Int]) -> Int { let mut s=0; for n in a { s=s+n }; s }
fn sum_fold(a : Array[Int]) -> Int { a.fold(0, fn(acc,n){ acc+n }) }
```

用相同输入比对结果与时间（后续性能章节更详）。

### 练习 4-14

- 编写两个版本函数：命令式与表达式式；记录可读性与主观可维护性评分。

---

## 4.20 挑战练习（综合与开放）

1. 设计一个小型“统计库”：暴露 `mean`, `median`, `variance`（可先假设输入长度>0），要求：纯函数、内部复用。编写一个 `main` 演示。
2. 实现一个函数生成器：`make_retry(times : Int, f : () -> Result)`（自定义枚举），返回包装后的函数，调用时自动重试失败的内部函数。
3. 使用闭包实现简单缓存：`memo_add_one()` 返回函数，对相同输入只计算一次（可用数组或简单映射模拟）。
4. 组合高阶函数与部分应用写“流水线”：对数组先过滤偶数，再乘 3，再求和。
5. 编写一份你的“函数设计守则”5 条，并用本章示例佐证。

> 提示：挑战题没有唯一答案；重点在结构与可读性。可将实现放在 `examples/` 目录（若创建）。
