# 第 5 章 数据类型（系统化）

本章目标：系统、耐心、逐项解释 MoonBit 中常见基础与复合数据类型。我们不假设读者懂“类型系统”或其它语言差异。示例全部可运行。理解类型有助于：

- 写出更少运行时错误的代码（编译期发现问题）
- 选择合适的表示方式（性能/表达力）
- 看懂编译器报错与自动推断行为

---

## 5.1 什么是“类型”？

类型可以理解为：一种值的“形状 + 允许的操作集合”。编译器借此做：

- 检查：你是否对值做了合法操作（`Int` 上算术 OK，`String` 上直接相加可能不同语义）。
- 推断：在上下文明确时猜出缺省类型。
- 优化：知道布局，可生成更高效指令。

值 vs 类型类比：

```
值： 42      → 属于 Int
值： "hi"    → 属于 String
值： (true,5)→ 属于 (Bool, Int) 元组类型
```

---

## 5.2 基本类型总览

- `Unit`：表示“无意义”结果，仅一个值 `()`。
- `Bool`：布尔，`true/false`。
- 整数：`Int`、`Int64`、`UInt`、`UInt64`。
- 浮点：`Float`（32 位）、`Double`（64 位）。
- `String`：一串 UTF-16 码点。
- `Char`：单个 Unicode 码点。
- `Byte`：0..255 单字节；`Bytes`：不可变字节序列。
- 组合：元组 `(A,B,...)`、数组 `Array[T]` / `FixedArray[T]`。
- 枚举、记录/结构（若语言提供；本章只点到枚举用法）。

---

## 5.3 Unit —— 空信息占位符

```moonbit expr
fn do_side_effect {
  println("Logging...")
}
fn main {
  let r = do_side_effect()  // r 类型是 Unit
  println(r)                // 打印可能为空表示
}
```

使用场景：执行动作但不产生“意义”值；接口统一（需要有返回类型的位置可放 Unit）。不要把 Unit 当成“错误”或“成功”标记，真正需要可定义枚举。

### 练习 5-1

- 写一个函数执行两次打印，验证其返回值绑定后仍是 Unit。

---

## 5.4 Bool —— 条件的基石

逻辑运算：`&&`（与）、`||`（或）、`not(x)`（非）。短路：左侧已能决定结果时右侧不再求值。

```moonbit expr
fn main {
  let a = true
  let b = false
  println(a && b)  // false
  println(a || b)  // true
  println(not(a))  // false
}
```

### 练习 5-2

- 构造一个表达式，右侧包含 `println("should not run")`，利用短路避免执行。

---

## 5.5 数字类型详解

选择策略：

- 默认使用 `Int`（够用且常见）。
- 需要更大范围：`Int64`。
- 明确不可能为负、或做位运算：`UInt`/`UInt64`。
- 浮点：`Double` 一般即可；`Float` 用于节省内存或与外部接口对接。

### 5.5.1 字面量与进制

```moonbit expr
fn main {
  let dec = 1_000_000
  let bin = 0b1010
  let oct = 0o123
  let hex = 0xFF
  let hex_float = 0x1.2P3  // (1 + 2/16)*2^3 = 9
  println(dec)
  println(bin)
  println(oct)
  println(hex)
  println(hex_float)
}
```

分隔符 `_` 仅增强可读性。

### 5.5.2 类型推断与后缀

```moonbit expr
fn main {
  let a : Int = 42
  let b : UInt = 42
  let c : Int64 = 42
  let f : Float = 3.14
  let d : Double = 3.14
  println(a + b.to_int())
}
```

误区：误认为写成 `42L` 等后缀才算某类型；实际上上下文足够时无需后缀。

### 练习 5-3

- 写一个例子同时声明 Int、UInt、Int64、Double，并打印。

---

## 5.6 String —— 文本与插值

创建与多行：

```moonbit expr
fn main {
  let single = "兔rabbit"
  let multi =
    #| Line1
    #| Line2
  println(single)
  println(multi)
}
```

插值：

```moonbit expr
fn main {
  let x = 42
  println("ans=\{x}")
  println("calc=\{x + 8}")
}
```

限制：插值内部不能包含未闭合的 `{}`、换行或 `"`。

转义：`\n \t \" \\ \u{1F600}` 等。

### 多行区分

- `#|` 原样保留，不处理插值/转义。
- `$|` 处理插值与转义，适合模板。

### 练习 5-4

- 写一个 `$|` 多行模板，包含变量插值与换行。

---

## 5.7 Char 与 Byte/Bytes

```moonbit expr
fn main {
  let ch : Char = '兔'
  let a : Char = 'A'
  let ascii_a : Byte = b'a'
  println(ch)
  println(ascii_a.to_int())  // 97
}
```

区分：`Char` 面向“字符语义”（Unicode），`Byte` 是裸数值（0..255）。处理文本时不要混用导致乱码。

`Bytes`：不可变字节序列，用于二进制数据：

```moonbit expr
fn main {
  let b1 : Bytes = b"abcd"
  let b2 = b"\x61\x62\x63\x64"
  println(b1 == b2)  // true
}
```

### 练习 5-5

- 写一个函数接收 `Bytes` 打印每个字节的整数值。

---

## 5.8 元组 (Tuple)

按“位置”组合不同类型：

```moonbit expr
fn pack(a : Bool, b : Int, c : String) -> (Bool, Int, String) { (a,b,c) }
fn main {
  let t = pack(true, 7, "hi")
  let first = t.0
  let (b,i,s) = t
  println(first)
  println(s)
}
```

对比数组：元组长度与类型在编译期固定；数组长度可变（`Array`）。命名需求强时考虑枚举/记录（后续章节）。

### 练习 5-6

- 定义一个三元组 `(Int, String, Bool)`，解构后打印每个值。

---

## 5.9 数组：Array vs FixedArray

```moonbit expr
fn main {
  let a : Array[Int] = [1,2,3]
  let f : FixedArray[Int] = [1,2,3]
  println(a[0])
  a[1] = 10
  println(a)
}
```

二维初始化陷阱：

```moonbit expr
fn main {
  let wrong = FixedArray::make(3, FixedArray::make(3,0))
  wrong[0][1] = 9
  println(wrong[2][1])  // 9, 意外共享

  let correct = FixedArray::makei(3, fn(_){ FixedArray::make(3,0) })
  correct[0][1] = 9
  println(correct[2][1]) // 0
}
```

选择：大多数情况用 `Array`；固定尺寸且性能敏感时用 `FixedArray`。

### 练习 5-7

- 构造一个 5x5 的 `FixedArray[FixedArray[Int]]` 并设置对角线为索引值。

---

## 5.10 枚举（示例性）

```moonbit expr
enum Weather { Sunny Rainy Cloudy Snowy }
fn advise(w : Weather) -> String {
  match w {
    Sunny => "Walk"
    Rainy => "Read"
    Cloudy => "Think"
    Snowy => "Play"
  }
}
fn main { println(advise(Sunny)) }
```

用途：表示“有限离散状态集合”。配合 `match` 极其清晰。若需要附加数据（如带温度）可扩展（假设语言支持带参数枚举）。

### 练习 5-8

- 自定义枚举 `TrafficLight` 三状态，并写函数返回下一状态（循环）。

---

## 5.11 Option 与空值处理（见可选参数）

使用场景：表达“可能有值”而非使用魔法数字/空字符串。模式：

```moonbit expr
fn width_or_default(w? : Int) -> Int {
  match w { Some(v) => v  None => 10 }
}
```

优势：编译器强迫处理 `None`，避免漏判空值。

### 练习 5-9

- 写函数 `safe_head(arr : Array[Int]) -> Option[Int]`：空数组返回 `None`，否则 `Some(first)`。

---

## 5.12 组合与抽象：何时自定义类型？

当：

- 多个值经常同时出现（坐标、区间） → 可封装成记录/结构（后续章节若提供）。
- 特定有限状态 → 枚举。
- 可选语义 → Option。
- 需表达不变量（如值域必须正数） → 自定义构造函数内保证。

### 练习 5-10 综合

- 设计一组类型描述“任务”：状态枚举（Pending/Running/Done）、任务元组 `(String, Int)` 表示名称与优先级，写函数根据状态输出友好描述。

---

## 5.13 小结

你已经掌握：基础类型、字面量、字符串插值、多行、字符与字节、元组、数组、枚举、Option 的基本思想。下一章（第 6 章）将讨论变量/常量与作用域，让这些类型在不同生命周期中安全流转。

---

## 5.14 自测

1. 写一个函数：接收枚举 `Weather` 与温度（Int），返回综合建议（用 `match`）。
2. 写 `parse_int(s : String) -> Option[Int]`（简单：空字符串返回 None，否则固定返回 0 代表演示）。
3. 写一个函数接收 `Array[Int]` 返回它的倒序新数组，不修改原始数组（纯函数）。

（答案见 `appendix/answers.md`）

---

## 5.15 类型转换与安全（Casting）

常见需求：把一个数值“视为”更宽或更窄的类型、从文本解析数值。

- 拓宽（widen）通常安全：`Int` → `Int64`、`Float` → `Double`（不会丢失语义）。
- 收窄（narrow）可能溢出：`Int64` → `Int`（若值超过范围）。应在转换前检查范围。
- 字符串解析：可包装为 `Option` 或枚举以显式表明失败。

示例（伪装解析）：

```moonbit expr
enum IntParse { Ok(Int) Err(String) }
fn parse_digit(s : String) -> IntParse {
  if s == "0" { Ok(0) } else if s == "1" { Ok(1) } else { Err("only 0/1 supported") }
}
```

设计建议：所有潜在失败的转换避免返回“特殊值”(-1)，而是使用枚举或 Option。

### 练习 5-11

- 编写一个把 `Array[String]` 转成 `Array[Int]` 的函数，遇到无法解析的元素用枚举记录错误位置。

---

## 5.16 类型推断陷阱与显式注解策略

何时需要显式注解：

1. 空数组/空元组：编译器无法猜元素类型。
2. 多义表达式：字面量既可为多种数值类型。
3. 作为公共 API：函数签名、返回值必须清晰。

反例：

```moonbit expr
fn build_empty { let v = []; println(v) } // v 类型不明确
```

改良：

```moonbit expr
fn build_empty { let v : Array[Int] = []; println(v) }
```

### 练习 5-12

- 找出你代码里可以增加注解提升可读性的两处并改写。

---

## 5.17 集合与数据操作：语义 vs 副作用

`map / filter / fold`（假设可用）倡导“声明式”风格：

- `map`：结构保持长度不变，逐元素转换。
- `filter`：保留满足条件元素，可能改变长度。
- `fold`：从初始累加器归约为单值（或结构）。

示例组合：

```moonbit expr
fn process(nums : Array[Int]) -> Int {
  nums.filter(n => n%2==0).map(n => n*3).fold(0, fn(acc,n){ acc+n })
}
```

对比命令式：

```moonbit expr
fn process_loop(nums : Array[Int]) -> Int {
  let mut acc = 0
  for n in nums { if n%2==0 { acc = acc + n*3 } }
  acc
}
```

### 练习 5-13

- 写两个版本的同一数据处理函数并比较行数与可读性。

---

## 5.18 Option/枚举与“空值”替代

避免：用特殊数字/空字符串表示“无值”容易与合法数据冲突。
惯例：

- 可选字段 → `Option[T]`。
- 操作结果 → `Result` 风格枚举（Ok/Err）。
- 状态机 → 多枚举值表示各阶段。

组合示例：

```moonbit expr
enum Load { Pending Success(String) Failed(String) }
fn render(load : Load) -> String {
  match load { Pending=>"..." Success(data)=>data Failed(msg)=>"error:" + msg }
}
```

### 练习 5-14

- 设计一个枚举描述文件读取三阶段（未开始 / 已加载内容 / 失败），并写一个渲染函数。

---

## 5.19 领域建模：用类型表达不变量

场景：很多逻辑依赖“值必须满足条件”。不要到处 `if x>0`，而是在构造时校验。
示例（正数包装类型——伪例，可视语言特性调整）：

```moonbit expr
enum Positive { Pos(Int) Err(String) }
fn make_positive(n : Int) -> Positive { if n>0 { Pos(n) } else { Err("not positive") } }
```

使用：拿到 `Pos(v)` 后无需再次检查 v>0。

原则：类型驱动的正确性 > 运行期重复检查。

### 练习 5-15

- 针对“任务优先级必须 1..5”设计一个构造函数与枚举，避免非法值传播。

---

## 5.20 性能与内存简注意事项（初步）

类型选择影响性能：

- 数值：过度使用 64 位在某些平台可能增加内存占用。
- 字符串构建：频繁拼接可考虑一次性插值，而非多次累加（视实现）。
- 大数组：避免重复复制，采用纯函数时不要每步无谓创建中间结构（必要时可优化为单次循环）。

### 练习 5-16

- 写一个函数对数组做三步转换（过滤、映射、再过滤），再写一个单循环等价版本比较复杂度与可读性。

---

## 5.21 挑战练习

1. 构建一个“库存”模型：商品枚举（书/电子/食品），每种附加不同属性（可用多个结构或简化字符串），返回总价值聚合报告。
2. 实现一个安全的“拆分字符串为数字”函数：遇到任一失败整体返回错误枚举并列出失败索引列表。
3. 设计一个简单评分类型：原始分数（0..100）包装为枚举（Low/Medium/High），再写显示函数。
4. 编写一个类型驱动的配置加载：缺省值与用户覆盖组合成最终结构，缺失字段使用默认。
5. 记录你在本章遇到的 3 个“类型帮助发现的错误”并说明。

> 提示：挑战题强调“用类型表达规则”，保持练习答案的简洁与明确。
