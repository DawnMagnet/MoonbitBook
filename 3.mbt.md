# 第三章 MoonBit 语法

本章目标：用尽量少的术语、更多实例，把「MoonBit 的基本语法」讲清楚。阅读时可一边看一边敲代码，遇到不懂的词先看本节的「术语小卡」，再看示例和解释。

小提示：本章所有示例都可单独运行。MoonBit 以表达式为中心，很多语句本身就是「有值的表达式」。

术语小卡：

- 表达式：能计算出一个值的代码片段，例如 1 + 2、x > 3、函数调用等。
- 语句：完成某个动作的代码，例如变量绑定、循环等。MoonBit 中很多语句也能产生值。
- 字面量：直接写在代码中的常量，比如 42、"hello"、0x10。
- 绑定/变量：用 let 绑定一个名字到某个值上。
- 类型：值的「形状」和「可做的事」，编译器据此检查正确性。

## 3.1 函数定义

首先让我们看第一个`moonbit`程序

```moonbit expr
fn main {
  print("Hello, world!")
}
```

这是一个函数定义，`fn` 是定义函数的关键字，`main` 是函数的名称。函数体用大括号 `{}` 包围，里面是函数的具体实现。我们可以注意到，整个程序仅仅包含了这一个函数定义。

函数，在数学中是一个输入和输出之间的映射关系，而在编程中，函数则是一个可以被调用的代码块，可以理解为一个功能合集。在`moonbit`中，函数是非常重要的概念，它是程序的基本构建块。

在该段程序中，出现了两个函数，分别是 `main` 和 `print`。其中 `main` 是程序的入口函数，而 `print` 是一个内置函数，用于输出文本。

> 内置函数即是编程语言本身提供的函数，无需用户定义即可使用。一般称为标准库函数。

函数体用大括号 `{}` 包围，里面是函数的具体实现。函数体可以包含任意多条语句。

初学者易混点：

- 无参数函数可以省略圆括号，所以上面的 `fn main { ... }` 是合法的；有参数时需要写成 `fn foo(x : Int) { ... }`。
- `print` 不会自动换行；`println` 会在最后附加一个换行。需要换行时更常用 `println`。
- 在 MoonBit 中，函数的返回值通常是「最后一个表达式的值」。若函数没有有意义的结果，返回 `Unit`（见 3.2.1）。

小练习：

1. 写一个函数 `greet`，打印 "Hello, MoonBit!"。
2. 再写一个函数 `add`，接收两个 `Int`，返回它们的和，并在 `main` 中调用。

### 3.1.2 特殊功能函数

在 `moonbit` 中，函数的定义和调用是非常灵活的。除了普通的函数定义外，还有一些特殊的功能函数。这些函数往往跟程序运行的环境或状态相关，具有特殊的功能。

1. `main`函数：

   - `main` 函数是程序的入口函数。当程序运行时，`main` 函数会被自动调用。
   - `main` 函数没有任何参数和返回值。
   - 每个 `moonbit` 程序都必须有一个 `main` 函数，且最多有一个。
   - 在库程序中，`main` 函数不能出现，但在可执行程序中必须存在。

2. `init`函数：
   - `init` 函数在程序开始运行之前被调用。它通常用于初始化一些全局变量或资源。
   - `init` 函数没有任何参数和返回值。
   - `init` 函数可以有多个。所有的 `init` 函数会在 `main` 函数之前被调用。

例如:

```moonbit expr
fn init {
  println("Initializing...")
}
```

进一步解释：

- 如果存在多个 `init`，它们的调用顺序由编译器/链接顺序决定，一般不应依赖顺序来写逻辑；把共享初始化拆到可重入的普通函数里更稳妥。
- 可执行程序需要一个且仅一个 `main`；做成库时不应出现 `main`，而是暴露供他人调用的函数。

常见问题：

- 问：能给 `main` 写参数吗？答：不行，`main` 固定为无参、无返回值的入口点。

## 3.2 基础数据类型

在编程中，数据类型是对数据的一种分类，用于告诉计算机如何存储和操作这些数据。MoonBit 提供了多种内置的数据类型，让我们能够有效地处理不同种类的信息。

### 3.2.1 Unit 类型

`Unit` 是 MoonBit 中的一个特殊类型，它表示"无意义的值"。它只有一个值，写作 `()`。`Unit` 类似于其他语言中的 `void`，但与 `void` 不同的是，它是一个真正的类型，可以在任何需要类型的地方使用。

```moonbit expr
fn print_hello() -> Unit {
  println("Hello, world!")
}

fn main {
  let result = print_hello()  // result 的类型是 Unit
  println("Function returned")  // 输出: Function returned
}
```

`Unit` 类型通常用作执行某些操作但不产生有意义结果的函数的返回类型。与其他一些语言不同，MoonBit 将 `Unit` 视为一等类型，允许它在泛型中使用、存储在数据结构中以及作为函数参数传递。

理解要点：

- 可把 `Unit` 理解为「空元组」：占位但没有承载信息。
- 当函数主要是「做事」（比如打印、写文件）而不是「产生值」时，返回 `Unit` 很自然。

### 3.2.2 布尔类型

MoonBit 有一个内置的布尔类型 `Bool`，它有两个值：`true` 和 `false`。布尔类型用于条件表达式和控制结构。你可以认为其表示真或假，

```moonbit expr
fn main {
  let a = true
  let b = false
  let c = a && b // 逻辑与，结果为 false
  let d = a || b // 逻辑或，结果为 true
  let e = not(a) // 逻辑非，结果为 false
  println(c) // 输出: false
  println(d) // 输出: true
  println(e) // 输出: false
}
```

布尔值常用于条件判断和循环控制中，是程序逻辑的重要组成部分。

补充说明：

- `&&` 和 `||` 采用短路求值：当左侧足以决定结果时，不再计算右侧表达式。利用这一点可以避免不必要的计算或错误。

### 3.2.3 数字类型

MoonBit 提供了多种数字类型，包括整数类型和浮点类型：

| 类型   | 描述                         | 示例           |
| ------ | ---------------------------- | -------------- |
| Int    | 32 位有符号整数              | 42             |
| Int64  | 64 位有符号整数              | 1000L          |
| UInt   | 32 位无符号整数              | 14U            |
| UInt64 | 64 位无符号整数              | 14UL           |
| Double | 64 位浮点数，由 IEEE754 定义 | 3.14           |
| Float  | 32 位浮点数                  | (3.14 : Float) |

```moonbit expr
fn main {
  let a = 1234 // Int 类型
  let b : Int = 1_000_000 + a // 可以用下划线提高可读性
  let unsigned_num : UInt = 4_294_967_295U
  let large_num : Int64 = 9_223_372_036_854_775_807L
  let unsigned_large_num : UInt64 = 18_446_744_073_709_551_615UL
  println(a) // 输出: 1234
  println(b) // 输出: 1001234
}
```

#### 3.2.3.1 数字字面量

MoonBit 支持多种进制的数字字面量：

**十进制数字：** 默认的数字格式，可以包含下划线来提高可读性。

```moonbit expr
fn main {
  let decimal = 1_000_000
  println(decimal)  // 输出: 1000000
}
```

**二进制数字：** 使用 `0b` 或 `0B` 前缀。

```moonbit expr
fn main {
  let bin = 0b110010    // 二进制 110010，等于十进制 50
  let another_bin = 0B110010
  println(bin)  // 输出: 50
}
```

**八进制数字：** 使用 `0o` 或 `0O` 前缀。

```moonbit expr
fn main {
  let octal = 0o1234        // 八进制 1234，等于十进制 668
  let another_octal = 0O1234
  println(octal)  // 输出: 668
}
```

**十六进制数字：** 使用 `0x` 或 `0X` 前缀。

```moonbit expr
fn main {
  let hex = 0XA             // 十六进制 A，等于十进制 10
  let another_hex = 0xA_B_C // 十六进制 ABC，等于十进制 2748
  println(hex)         // 输出: 10
  println(another_hex) // 输出: 2748
}
```

**浮点数字：** 浮点数字面量默认是 64 位浮点数。

```moonbit expr
fn main {
  let double = 3.14                      // Double 类型
  let float : Float = 3.14               // 需要类型注释指定为 Float
  let float2 = (3.14 : Float)            // 或者使用类型转换
  let hex_double = 0x1.2P3               // 十六进制浮点数: (1.0 + 2/16) * 2^3 = 9.0

  println(double)     // 输出: 3.14
  println(hex_double) // 输出: 9
}
```

#### 3.2.3.2 自动类型推断

当期望的类型已知时，MoonBit 可以自动重载字面量，无需通过字母后缀指定数字的类型：

```moonbit expr
fn main {
  let int : Int = 42
  let uint : UInt = 42
  let int64 : Int64 = 42
  let double : Double = 42
  let float : Float = 42

  println(int)    // 输出: 42
  println(uint)   // 输出: 42
  println(int64)  // 输出: 42
}
```

选择哪种整数？

- 优先用 `Int` 满足大多数业务计数/索引；需要更大范围再考虑 `Int64` 或无符号类型。
- 无符号类型（`UInt/UInt64`）不表示负数，常用于位运算或明确不可能为负的计数。

### 3.2.4 字符串类型

`String` 包含一系列 UTF-16 码点。您可以使用双引号创建字符串，或使用 `#|` 编写多行字符串。

```moonbit expr
fn main {
  let a = "兔rabbit"
  println(a)

  let b =
    #| Hello
    #| MoonBit
    #|
  println(b)
}
```

#### 3.2.4.1 转义序列

在双引号字符串中，反斜杠后跟某些特殊字符形成转义序列：

| 转义序列               | 描述                         |
| ---------------------- | ---------------------------- |
| `\n`, `\r`, `\t`, `\b` | 换行，回车，水平制表符，退格 |
| `\\`                   | 反斜杠                       |
| `\"`                   | 双引号                       |
| `\u5154`, `\u{1F600}`  | Unicode 转义序列             |

```moonbit expr
fn main {
  let escaped = "Hello\nWorld!\t\"MoonBit\""
  println(escaped)
  // 输出:
  // Hello
  // World!    "MoonBit"
}
```

#### 3.2.4.2 字符串插值

MoonBit 支持字符串插值，允许您在插值字符串中替换变量。用于字符串插值的变量必须实现 Show 特征。

```moonbit expr
fn main {
  let x = 42
  let name = "MoonBit"
  println("The answer is \{x}")           // 输出: The answer is 42
  println("Hello, \{name}!")              // 输出: Hello, MoonBit!
  println("Result: \{x + 8}")             // 输出: Result: 50
}
```

> 注意：插值表达式不能包含换行符、`{}` 或 `"`。

实用提示：

- `String` 通常是不可变的。如需构造复杂字符串，优先用插值或把片段拼接成新字符串，而不是「原地修改」。

#### 3.2.4.3 多行字符串

多行字符串可以使用前缀 `#|` 或 `$|` 定义，其中前者将保留原始字符串，后者将执行转义和插值：

```moonbit expr
fn main {
  let lang = "MoonBit"
  let str =
    #| Hello
    #| ---
    $| \{lang}
    #| ---
  println(str)
  // 输出:
  //  Hello
  //  ---
  //  MoonBit
  //  ---
}
```

差异总结：

- `#|` 原样保留内容（不做转义/插值）；
- `$|` 会进行转义和插值，便于在多行中插入变量。

### 3.2.5 字符类型

`Char` 表示一个 Unicode 码点。

```moonbit expr
fn main {
  let a : Char = 'A'
  let b = '兔'
  let zero = '\u{30}'      // Unicode 转义序列
  let zero2 = '\u0030'     // 另一种 Unicode 转义格式

  println(a)     // 输出: A
  println(b)     // 输出: 兔
  println(zero)  // 输出: 0
}
```

当期望类型是 `Int` 时，字符字面量可以重载为类型 `Int`：

```moonbit expr
fn main {
  let s : String = "hello"
  let b = s.charcode_at(0) - 'a'  // 'a' 被转换为 Int 类型
  println(b)  // 输出: 7 (h 的 ASCII 码 104 - a 的 ASCII 码 97)
}
```

易错提醒：

- `Char` 描述的是 Unicode 字符，而 `Byte` 只覆盖 0..255 的单字节范围。处理中英文、emoji 时应使用 `Char/String`，不要用 `Byte` 代替字符。

### 3.2.6 字节类型

#### 3.2.6.1 Byte 类型

MoonBit 中的字节字面量是一个 ASCII 字符或一个转义序列，语法形式为 `b'...'`。字节字面量的类型是 `Byte`。

```moonbit expr
fn main {
  let b1 : Byte = b'a'
  println(b1.to_int())  // 输出: 97

  let b2 = b'\xff'
  println(b2.to_int())  // 输出: 255
}
```

#### 3.2.6.2 Bytes 类型

`Bytes` 是不可修改的字节序列。字节序列字面量的形式是 `b"..."`。

```moonbit expr
fn main {
  let b1 : Bytes = b"abcd"
  let b2 = b"\x61\x62\x63\x64"  // 等价于 b"abcd"
  println(b1 == b2)  // 输出: true
}
```

**Byte 和 Bytes 支持的转义序列：**

| 转义序列               | 描述                         |
| ---------------------- | ---------------------------- |
| `\n`, `\r`, `\t`, `\b` | 换行，回车，水平制表符，退格 |
| `\\`                   | 反斜杠                       |
| `\x41`                 | 十六进制转义序列             |
| `\o102`                | 八进制转义序列               |

### 3.2.7 元组类型

元组是使用圆括号 `()` 构造的有限值集合，元素之间用逗号 `,` 分隔。元素的顺序很重要。

```moonbit expr
fn main {
  fn pack(a : Bool, b : Int, c : String, d : Double) -> (Bool, Int, String, Double) {
    (a, b, c, d)
  }

  let quad = pack(false, 100, "text", 3.14)
  let (bool_val, int_val, str, float_val) = quad  // 解构元组
  println("\{bool_val} \{int_val} \{str} \{float_val}")
  // 输出: false 100 text 3.14
}
```

元组可以通过模式匹配或索引访问：

```moonbit expr
fn main {
  let t = (1, 2)
  let (x1, y1) = t    // 模式匹配方式
  let x2 = t.0        // 索引访问方式
  let y2 = t.1

  println("x1=\{x1}, y1=\{y1}")  // 输出: x1=1, y1=2
  println("x2=\{x2}, y2=\{y2}")  // 输出: x2=1, y2=2
}
```

补充：

- 元组是“按位置”的组合类型，类型由每个位置的类型和顺序决定。若需“按名字”访问字段，请考虑定义记录/结构（后续章节）。

### 3.2.8 数组类型

数组是使用方括号 `[]` 构造的有限值序列，元素之间用逗号 `,` 分隔。

```moonbit expr
fn main {
  let numbers = [1, 2, 3, 4]
  println(numbers[2])  // 输出: 3 (索引从 0 开始)

  numbers[3] = 5       // 修改数组元素
  println(numbers[3])  // 输出: 5
}
```

MoonBit 有两种数组类型：

- `Array[T]`：可以增长的动态数组
- `FixedArray[T]`：固定大小的数组

```moonbit expr
fn main {
  // 动态数组
  let dynamic_array : Array[Int] = [1, 2, 3]

  // 固定数组
  let fixed_array : FixedArray[Int] = [1, 2, 3]

  // 当期望的类型已知时，MoonBit 可以自动推断
  let array_auto = [1, 2, 3]  // 默认为 Array[Int]
}
```

**创建固定数组时的注意事项：**

```moonbit expr
fn main {
  // 错误的方式：所有元素共享同一个对象
  let wrong_2d = FixedArray::make(10, FixedArray::make(10, 0))
  wrong_2d[0][5] = 10
  println(wrong_2d[5][5])  // 输出: 10 (意外的结果！)

  // 正确的方式：为每个位置创建新对象
  let correct_2d = FixedArray::makei(10, fn(_i) {
    FixedArray::make(10, 0)
  })
  correct_2d[0][5] = 10
  println(correct_2d[5][5])  // 输出: 0 (正确的结果)
}
```

选择建议：

- 绝大多数情况下使用 `Array[T]`，需要固定大小且追求初始化性能/内存布局时再选 `FixedArray[T]`。
- 二维/多维固定数组初始化时，注意避免「所有行引用同一对象」的别名问题，优先使用 `makei` 按索引逐一构造。

## 3.3 变量与常量

在编程中，我们经常需要存储和操作数据。MoonBit 提供了变量和常量两种方式来处理数据存储。

### 3.3.1 变量声明

在 MoonBit 中，使用 `let` 关键字声明变量。默认情况下，变量是不可变的：

```moonbit expr
fn main {
  let x = 5
  let y = 10
  let sum = x + y
  println("Sum: \{sum}")  // 输出: Sum: 15

  // x = 6  // 错误！x 是不可变的
}
```

要点：

- 绑定默认不可变，有利于推理和避免并发/状态相关错误；确实需要修改时再使用可变绑定。

### 3.3.2 可变变量

如果需要修改变量的值，可以使用 `mut` 关键字声明可变变量：

```moonbit expr
fn main {
  let mut x = 5
  println("Initial x: \{x}")  // 输出: Initial x: 5

  x = 10
  println("Updated x: \{x}")  // 输出: Updated x: 10

  x = x + 5
  println("Final x: \{x}")    // 输出: Final x: 15
}
```

常见报错：试图修改不可变绑定会报类似「cannot assign to immutable binding」的错误，确认是否忘了加 `mut`。

### 3.3.3 类型注解

MoonBit 具有强大的类型推断能力，但有时我们需要明确指定变量的类型：

```moonbit expr
fn main {
  let x : Int = 42
  let y : Double = 3.14
  let name : String = "MoonBit"
  let is_true : Bool = true

  println("x: \{x}, y: \{y}")
  println("name: \{name}, is_true: \{is_true}")
}
```

阅读注解的小技巧：`x : Int` 读作「x 的类型是 Int」。当推断不够明确、或你希望文档化变量含义时加上注解会更清晰。

### 3.3.4 常量声明

使用 `const` 关键字可以声明常量，常量必须在编译时确定其值：

```moonbit expr
const PI = 3.14159
const MAX_SIZE = 1000
const GREETING = "Hello, MoonBit!"

fn main {
  println("PI: \{PI}")
  println("Max size: \{MAX_SIZE}")
  println(GREETING)
}
```

规则与建议：

- 常量在编译期需可确定，适合放置配置信息、尺寸上限、固定字符串等。
- 命名建议使用全大写与下划线（如 `MAX_SIZE`），与普通变量区分。

## 3.4 控制结构

控制结构是编程语言中用于控制程序执行流程的重要工具。MoonBit 提供了多种控制结构，包括条件语句、循环语句和匹配表达式。

### 3.4.1 条件表达式

#### 3.4.1.1 基本 if 表达式

条件表达式由条件、结果和可选的 `else` 子句组成：

```moonbit expr
fn main {
  let x = 10
  let result = if x > 5 {
    "Greater than 5"
  } else {
    "Less than or equal to 5"
  }
  println(result)  // 输出: Greater than 5
}
```

#### 3.4.1.2 else if 链

可以使用 `else if` 处理多个条件：

```moonbit expr
fn main {
  let score = 85
  let grade = if score >= 90 {
    "A"
  } else if score >= 80 {
    "B"
  } else if score >= 70 {
    "C"
  } else if score >= 60 {
    "D"
  } else {
    "F"
  }
  println("Grade: \{grade}")  // 输出: Grade: B
}
```

注意：条件表达式在 MoonBit 中始终返回一个值，`if` 和 `else` 分支的返回值必须是相同的类型。

进一步说明：把 if 视为「有值的表达式」会让很多写法更简洁：可以直接把 if 的结果绑定给变量、或作为函数返回值。

### 3.4.2 匹配表达式

`match` 表达式是 MoonBit 中非常强大的控制结构，它使用模式匹配来决定要执行哪个分支：

```moonbit expr
enum Weather {
  Sunny
  Rainy
  Cloudy
  Snowy
}

fn decide_activity(weather : Weather) -> String {
  match weather {
    Sunny => "Go for a walk"
    Rainy => "Stay indoors and read"
    Cloudy => "Maybe go outside"
    Snowy => "Build a snowman"
  }
}

fn main {
  let today = Sunny
  let activity = decide_activity(today)
  println(activity)  // 输出: Go for a walk
}
```

理解方式：

- `match` 会把待匹配的值与每个分支的「模式」对比，命中哪一个就执行哪个分支的表达式。后续学习枚举、结构、解构时会更常用。

### 3.4.3 循环结构

#### 3.4.3.1 while 循环

`while` 循环在条件为真时重复执行代码块：

```moonbit expr
fn main {
  let mut i = 5
  while i > 0 {
    println("Countdown: \{i}")
    i = i - 1
  }
  println("Blast off!")
}
```

`while` 循环支持 `break` 和 `continue`：

```moonbit expr
fn main {
  let mut i = 10
  while i > 0 {
    i = i - 1
    if i == 7 {
      continue  // 跳过当前迭代
    }
    if i == 3 {
      break     // 退出循环
    }
    println(i)
  }
}
```

#### 3.4.3.2 for 循环

MoonBit 支持 C 风格的 for 循环：

```moonbit expr
fn main {
  for i = 0; i < 5; i = i + 1 {
    println("i = \{i}")
  }
}
```

变量初始化子句可以创建多个绑定：

```moonbit expr
fn main {
  for i = 0, j = 10; i < j; i = i + 1, j = j - 1 {
    println("i = \{i}, j = \{j}")
  }
}
```

#### 3.4.3.3 for..in 循环

`for..in` 循环用于遍历可迭代的数据结构：

```moonbit expr
fn main {
  // 遍历数组
  for x in [1, 2, 3, 4, 5] {
    println(x)
  }

  // 遍历范围
  for i in 0..<5 {    // 0 到 4
    println("Range: \{i}")
  }

  for i in 0..=5 {    // 0 到 5
    println("Inclusive range: \{i}")
  }
}
```

遍历带索引的数组：

```moonbit expr
fn main {
  let fruits = ["apple", "banana", "orange"]
  for index, fruit in fruits {
    println("\{index}: \{fruit}")
  }
  // 输出:
  // 0: apple
  // 1: banana
  // 2: orange
}
```

补充：

- 范围语法 `a..<b` 表示左闭右开（不含 b），`a..=b` 表示两端都包含。选择哪一种取决于业务语义。
- 遍历数组时，同时绑定 `index, value` 能更方便地拿到位置和值。

## 3.5 函数进阶

在前面我们已经介绍了基本的函数定义，现在让我们深入了解 MoonBit 中函数的高级特性。

总览：

- 函数是「一等公民」：可以作为值存入变量、当作参数传递、从函数返回。
- 没有显式 `return` 时，函数体中最后一个表达式的值就是返回值。

### 3.5.1 函数参数

#### 3.5.1.1 带标签的参数

顶层函数可以使用带标签的参数，提高代码的可读性：

```moonbit expr
fn create_user(name~ : String, age~ : Int, email~ : String) -> String {
  "User: \{name}, Age: \{age}, Email: \{email}"
}

fn main {
  // 可以按任意顺序提供带标签的参数
  let user1 = create_user(age=25, name="Alice", email="alice@example.com")
  let user2 = create_user(name="Bob", email="bob@example.com", age=30)

  println(user1)
  println(user2)
}
```

当变量名与标签名相同时，可以使用简写形式：

```moonbit expr
fn main {
  let name = "Charlie"
  let age = 28
  let email = "charlie@example.com"

  // name~ 是 name=name 的简写
  let user = create_user(name~, age~, email~)
  println(user)
}
```

#### 3.5.1.2 可选参数

可以为带标签的参数提供默认值，使其成为可选参数：

```moonbit expr
fn greet(name~ : String, greeting~ : String = "Hello") -> String {
  "\{greeting}, \{name}!"
}

fn main {
  println(greet(name="Alice"))                    // 使用默认 greeting
  println(greet(name="Bob", greeting="Hi"))       // 提供自定义 greeting
}
```

特殊的可选参数语法（自动 Some 包装）：

```moonbit expr
fn create_rectangle(width? : Int, height? : Int) -> String {
  let w = match width {
    Some(value) => value
    None => 10  // 默认宽度
  }
  let h = match height {
    Some(value) => value
    None => 10  // 默认高度
  }
  "Rectangle: \{w} x \{h}"
}

fn main {
  println(create_rectangle())                    // 使用默认值
  println(create_rectangle(width=20))            // 只指定宽度
  println(create_rectangle(width=20, height=30)) // 指定两个参数
}
```

概念说明：

- 这里的 `width? : Int` 表示该形参的实际类型是 `Option[Int]`，调用方写 `width=20` 会被自动包成 `Some(20)`；不写则是 `None`。
- 用 `match` 把 `Some/None` 拆开，填充默认值是很常见的写法。

#### 3.5.1.3 部分应用

MoonBit 支持函数的部分应用，通过 `_` 操作符实现：

```moonbit expr
fn add(x : Int, y : Int) -> Int {
  x + y
}

fn multiply(x : Int, y : Int, z : Int) -> Int {
  x * y * z
}

fn main {
  let add10 = add(10, _)        // 部分应用，固定第一个参数为 10
  println(add10(5))             // 输出: 15

  let mult_by_2_and_3 = multiply(_, 2, 3)  // 固定第二、三个参数
  println(mult_by_2_and_3(4))   // 输出: 24 (4 * 2 * 3)
}
```

理解 `_`：

- 下划线在这里是「参数占位符」，先固定（绑定）一部分参数，得到一个新的函数，等缺失的参数将来再补上。

### 3.5.2 匿名函数和闭包

#### 3.5.2.1 匿名函数

可以定义匿名函数并立即使用：

```moonbit expr
fn main {
  let numbers = [1, 2, 3, 4, 5]

  // 匿名函数
  let doubled = numbers.map(fn(x) { x * 2 })
  println(doubled)  // 输出: [2, 4, 6, 8, 10]

  // 箭头函数语法（更简洁）
  let squared = numbers.map(x => x * x)
  println(squared)  // 输出: [1, 4, 9, 16, 25]
}
```

#### 3.5.2.2 闭包

函数可以捕获其周围作用域的变量，形成闭包：

```moonbit expr
fn create_counter(initial : Int) -> () -> Int {
  let mut count = initial
  fn() {
    count = count + 1
    count
  }
}

fn main {
  let counter = create_counter(10)
  println(counter())  // 输出: 11
  println(counter())  // 输出: 12
  println(counter())  // 输出: 13
}
```

闭包直觉：

- 返回的函数「记住」了创建它时的环境（例子中的 `count`），因此每次调用都会在前一次基础上递增。
- 修改捕获变量需谨慎，尽量保持函数无副作用会更易测试与复用。

### 3.5.3 高阶函数

高阶函数是接受函数作为参数或返回函数的函数：

```moonbit expr
fn apply_twice(f : (Int) -> Int, x : Int) -> Int {
  f(f(x))
}

fn add_one(x : Int) -> Int {
  x + 1
}

fn double(x : Int) -> Int {
  x * 2
}

fn main {
  let result1 = apply_twice(add_one, 5)   // (5 + 1) + 1 = 7
  let result2 = apply_twice(double, 3)    // (3 * 2) * 2 = 12

  println(result1)  // 输出: 7
  println(result2)  // 输出: 12
}
```

应用场景：

- 把「做什么」作为参数传入，可以把流程复用、把变化点抽离出来。常见在集合操作（map/filter/reduce）中。

### 3.5.4 递归函数

MoonBit 支持递归函数，即函数调用自身：

```moonbit expr
fn factorial(n : Int) -> Int {
  if n <= 1 {
    1
  } else {
    n * factorial(n - 1)
  }
}

fn fibonacci(n : Int) -> Int {
  if n <= 1 {
    n
  } else {
    fibonacci(n - 1) + fibonacci(n - 2)
  }
}

fn main {
  println("5! = \{factorial(5)}")    // 输出: 5! = 120
  println("fib(8) = \{fibonacci(8)}") // 输出: fib(8) = 21
}
```

相互递归函数需要使用 `letrec` 语法：

```moonbit expr
fn main {
  letrec even = fn(x) { x == 0 || odd(x - 1) }
  and odd = fn(x) { x != 0 && even(x - 1) }

  println(even(4))  // 输出: true
  println(odd(4))   // 输出: false
  println(even(7))  // 输出: false
  println(odd(7))   // 输出: true
}
```

提醒：

- 递归很自然，但深度过大可能导致栈溢出；必要时改写为循环或使用尾递归风格（具体优化以编译器支持为准）。

——

本章小结：

- 你已经学会了 MoonBit 的函数、基础类型、变量与常量、控制流、函数进阶（标签参数、可选参数、闭包、递归）。
- 牢记几个要点：默认不可变、表达式有值、`if/match` 都是表达式、字符串插值很常用。

课后小练习：

1. 写一个函数 `grade(score : Int) -> String`，把分数映射为 A/B/C/D/F（用 `if` 或 `match`）。
2. 写一个函数 `sum(arr : Array[Int]) -> Int`，用 `for..in` 把数组求和。
3. 写一个闭包计数器 `create_counter()`，每次调用返回递增的数字，从 0 开始。
4. 写一个函数 `area(width? : Int, height? : Int)`，缺失时默认 10，返回字符串 "WxH=.."。
5. 定义一个枚举 `Weather`，配合 `match` 给出不同建议。

## 3.6 练习与自测（扩展）

### 基础巩固

1. 列出本章出现的所有“字面量”类型示例（数字、字符串、字符、字节、数组、元组等），并指出它们的直观含义。
2. 写一个使用标签参数与可选参数的函数 `profile(name~ : String, age? : Int)`；调用三种形式（无 age / 有 age / 顺序打乱）。
3. 构造一个错误案例：对不可变绑定赋值导致报错；再写一行正确实现（使用 `mut` 或 shadowing）。
4. 针对二维数组别名陷阱：写一个“错误版本”与一个“正确版本”，对比输出说明差异。
5. 使用 `match` 重写一段 4 层 `if/else if` 链（可任选分数分级或天气场景）。

### 进阶与思考

6. 设计一个闭包 `make_acc(step : Int)`：每次调用增加 step；写一版纯函数（返回新值）与一版修改捕获变量，比较风格差异。
7. 使用部分应用与高阶函数组合：定义 `operate(f : (Int)->Int, g : (Int)->Int, x : Int)`，再用部分应用固定其中一个函数生成新函数。
8. 写一个递归版本与循环版本的 `sum_range(n : Int)`（1..n 求和），比较可读性与潜在性能。
9. 枚举一个你在本章最容易混淆的概念（如：匿名函数 vs 箭头函数、Option vs 默认值），写 3 句区别说明。
10. 思考：如果未来要引入“异步/并发”特性，本章哪些概念（不可变、闭包、副作用）会直接影响编程模型？逐条写出理由。

> 建议：把第 6–10 题的思考写成 Markdown 笔记，后续阅读第 8、13 章时回顾并补充。选答题的多样性有助于加深理解。
