# 第 3 章 数据类型

在日常生活中，我们通过“分类”来认识世界：这是数字，那是文字；这是“真”的，那是“假”的。

在编程世界里，我们把这些分类称为**数据类型**。MoonBit 就像一个细心的管家，它要求我们在处理数据之前，先明确这个数据“是什么类型”。这样做的好处是，管家可以帮我们检查错误——比如，它会阻止你把“文字”和“数字”强行加在一起。

本章我们将用最通俗易懂的方式，带你认识 MoonBit 中最基础、最常用的几种数据类型。

## 3.0 什么是数据类型？

让我们先看一个简单的例子：

> **“苹果”是“水果”**

在这句话里：

- **“苹果”** 是一个具体的东西（我们称之为**值**）。
- **“水果”** 是这一类东西的统称（我们称之为**类型**）。

在编程中也是一样：

- `100` 是一个具体的值，它的类型是 **整数**。
- `"你好"` 是一个具体的值，它的类型是 **字符串**。

数据类型就像是给数据贴上的标签，告诉计算机：“这是一个数字，你可以拿它做加减法”或者“这是一段文字，你可以把它打印出来”。

---

## 3.1 Unit 类型：表示“这就完事了”

### 这是什么？

想象一下，你让朋友帮你做两件事：

1. **“帮我算一下 1 加 1 等于几？”** 朋友会回答你：“2”。这里有一个有意义的结果（数字 2）。
2. **“帮我把灯关一下。”** 朋友走过去关了灯。这件事做完了，但并没有产生一个新的“数字”或“文字”给你，只是事情**做完了**。

在 MoonBit 中，像“关灯”这种“只做事、不产生具体结果”的情况，也有一个专门的类型，叫做 `Unit`。

### 它的样子

- **类型名字**：`Unit`
- **它的值**：`()` （看起来像一对空荡荡的小括号，表示“空空如也”）

### 什么时候遇到？

当你写一段代码，主要目的是为了**产生某种效果**（比如在屏幕上打印一行字），而不是为了计算出一个数时，这段代码的结果通常就是 `Unit`。

```moonbit expr
fn main {
  // println 这个命令负责在屏幕上显示文字
  // 它做完这件事就结束了，不会这就给你变出一个数字来
  // 所以它的结果就是 ()
  println("Hello!")
}
```

---

## 3.2 Bool 类型：非真即假

### 这是什么？

这是最简单直接的类型，只有两种可能：**对**（真）或者**错**（假）。就像回答“是/否”问题一样。

### 它的样子

- **类型名字**：`Bool` (布尔值)
- **它的值**：只有两个 —— `true` (真) 和 `false` (假)。

### 怎么玩？

你可以像做逻辑题一样组合它们：

- **并且 (`&&`)**：只有两边都为真，结果才为真。（我想去玩 **并且** 天气好 -> 我才去）
- **或者 (`||`)**：只要有一边为真，结果就为真。（今天是周末 **或者** 我请假了 -> 我都不用上班）
- **不 (`not`)**：黑变白，白变黑。（**不**是下雨天 -> 那就是没下雨）

```moonbit expr
fn main {
  let is_weekend = false  // 不是周末
  let is_holiday = true   // 但是是节假日

  // 是周末 或者 是节假日，都可以休息
  let can_rest = is_weekend || is_holiday

  println(can_rest) // 输出: true (真，可以休息！)
}
```

---

## 3.3 整数类型：没有小数点的数字

### 这是什么？

就是我们在数学课上学的**整数**：0, 1, 2, 100, -5 等等。不带小数点。

### 它的样子

MoonBit 里有几种不同大小的“盒子”来装整数，最常用的是：

- **`Int`**：最常用的整数类型。就像一个**普通的背包**，日常用的数字都能装得下。具体的范围为 -2,147,483,648 到 2,147,483,647。
- **`Int64`**：超大整数。就像一个**集装箱**，如果你的数字特别特别大（比如全世界人口总数，或者宇宙里的星星数量，或者进行很大的数学运算），用它。
- **`Byte`**：微型整数。就像一个**火柴盒**，只能装 0 到 255 之间的数字。

### 注意事项

MoonBit 很严格，**不同大小的盒子不能混着用**。你不能直接把“集装箱”里的东西倒进“背包”里，必须显式地告诉它“我要转换一下”。

```moonbit expr
fn main {
  let small_num : Int = 10
  let big_num : Int64 = 100L // 数字后面加 L 表示这是个大整数

  // 下面这行会报错！因为一个是 Int，一个是 Int64
  // println(small_num + big_num)

  // 正确做法：先把 Int 变成 Int64，再相加
  println(small_num.to_int64() + big_num)
}
```

---

## 3.4 浮点数类型：带小数点的数字

### 这是什么？

就是**小数**。比如 3.14, 0.5, -1.2。因为小数点可以在数字间“浮动”（科学计数法），所以叫浮点数。

### 它的样子

- **`Double`**：双精度浮点数。这是默认的小数类型，精度比较高。
- **`Float`**：单精度浮点数。占空间小，但精度稍微低一点。

### 小心陷阱！

计算机存小数有时候存不准（就像 1/3 永远写不完一样）。
比如 `0.1 + 0.2` 在计算机里可能不完全等于 `0.3`，而是一个极度接近 `0.30000000000000004` 的数。所以，**不要直接判断两个小数是否完全相等**。

> 尝试一下下面的代码，看看结果是什么：

```moonbit expr
fn main {
  let price = 9.99
  let discount = 0.8
  let final_price = price * discount
  println(final_price)
}
```

---

## 3.5 String 类型：字符串

### 这是什么？

**字符串**就是一串字符连在一起，用来表示文本。就像项链（String）把一颗颗珠子（字符）串起来一样。

### 它的样子

- 用双引号括起来：`"你好，MoonBit"`
- **类型名字**：`String`

### 怎么玩？

最常用的功能是**插值**（填空题）。你可以在字符串里挖个坑，把变量填进去。

```moonbit expr
fn main {
  let name = "小明"
  let age = 18

  // \{name} 就是挖的坑，把 name 变量的值填进去
  let intro = "大家好，我是\{name}，今年\{age}岁。"

  println(intro)
  // 输出：大家好，我是小明，今年18岁。
}
```

---

## 3.6 Char 与 Bytes：单个字符与原始数据

这一节稍微高级一点点，初学者只需了解即可。

- **`Char` (字符)**：如果说 String 是一串项链，Char 就是项链上的**这一颗珠子**。它用单引号表示，比如 `'A'` 或 `'中'`。
- **`Bytes` (字节序列)**：这是给计算机看的“原始数据”。如果你要处理图片文件或者网络数据包，才会用到它。平时我们用 String 就够了。

---

## 3.7 元组 (Tuple)：固定搭配的套餐

### 这是什么？

有时候你想把几个**不同类型**的东西捆绑在一起，当成一个整体。
比如：一个学生的记录，包含“姓名”（文字）和“分数”（数字）。

### 它的样子

用圆括号括起来，中间用逗号分隔：`("小红", 98)`。

### 怎么玩？

就像买快餐套餐，你可以一次拿到汉堡和可乐。

```moonbit expr
fn main {
  // 定义一个元组：(String, Int)
  let student = ("小红", 98)

  // 访问里面的东西：用 .0 拿第一个，.1 拿第二个
  println(student.0) // 输出：小红
  println(student.1) // 输出：98

  // 或者直接把它们拆开（解构）
  let (name, score) = student
  println("姓名: \{name}, 分数: \{score}")
}
```

---

## 3.8 数组 (Array)：一排储物柜

### 这是什么？

如果你有一堆**相同类型**的东西要存，比如全班 50 个人的分数，用元组就不合适了。这时候用**数组**。
数组就像一排编号的储物柜，每个柜子大小一样，里面放的东西类型也必须一样。

### 它的样子

用方括号括起来：`[1, 2, 3, 4, 5]`。

### 怎么玩？

- **编号从 0 开始**：第一个柜子是 0 号，第二个是 1 号...
- **可以修改**：你可以把 0 号柜子里的东西拿出来，换个新的进去。

```moonbit expr
fn main {
  let scores = [80, 90, 95]

  // 拿出第 2 个分数（编号为 1）
  println(scores[1]) // 输出 90

  // 修改第 1 个分数（编号为 0）
  scores[0] = 85
  println(scores[0]) // 输出 85
}
```

---

## 3.9 Option 类型：神奇的盲盒

### 这是什么？

这是 MoonBit 里非常棒的一个设计！
在很多编程语言里，如果你想表示“这里没有值”，很容易导致程序崩溃（著名的“空指针异常”）。
MoonBit 用一种更安全的方式：**Option（选项）**。

想象一个盒子，这个盒子可能：

1. **装了一个东西** (`Some(值)`)
2. **是空的** (`None`)

当你处理这个盒子时，MoonBit 会强迫你必须考虑“如果是空的怎么办？”这样你就永远不会因为忘记检查空值而让程序崩溃了。

### 它的样子

- `Some(100)`：盒子里有个数字 100。
- `None`：盒子是空的。

### 怎么玩？

你需要“打开盒子”看看里面有没有东西。

```moonbit expr
fn main {
  // 假设这是一个可能为空的盒子
  let box : Option[Int] = Some(100)

  // 使用 match (匹配) 来打开盒子
  match box {
    Some(value) => println("盒子里有东西，是：\{value}")
    None => println("盒子是空的！")
  }
}
```

---

## 3.10 小结

恭喜你！你已经认识了 MoonBit 世界里的主要居民：

- **Unit**：表示“事情做完了，没啥结果”。
- **Bool**：表示“真”或“假”。
- **Int/Double**：表示“整数”或“小数”。
- **String**：表示“文字”。
- **Tuple**：把不同东西打包成“套餐”。
- **Array**：把同类东西排成“队列”。
- **Option**：安全的“盲盒”，处理可能为空的情况。

掌握了这些，你就拥有了构建程序大厦的砖块。下一章，我们将学习如何用**函数**来指挥这些数据动起来！
